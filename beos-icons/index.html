<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>BeOS icons</title>
  <meta property="og:title" content="BeOS icons" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="BeOS icons" />
  <meta property="og:description" content="A large collection of classic BeOS r5, Haiku OS, Zeta OS, and other retro operating system icons in PNG format." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://maxbo.me/beos-icons/" />
  <meta property="og:image" content="https://maxbo.me/beos-icons/og.png" />
  <meta property="og:site_name" content="maxbo.me" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="BeOS icons" />
  <meta name="twitter:description" content="A large collection of classic BeOS r5, Haiku OS, Zeta OS, and other retro operating system icons in PNG format." />
  <meta name="twitter:image" content="https://maxbo.me/beos-icons/og.png" />
  <style>
    body { margin: 1.25em; }
    h2 { margin-left: 1vw; border-bottom: 1px solid black; }
    h3 { margin-left: 2vw; color: #888; border-bottom: 1px dotted #888; }
    .category { margin-bottom: 1em; }
    .icon-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(4em, 1fr)); gap: 0.5em; margin-bottom: 0.9375em; margin-left: 3vw; }
    .icon-item { text-align: center; padding: 0.25em;  }
    .icon-item img { 
      image-rendering: pixelated;
      display: block; 
      margin: 0 auto 0.125em;
      width: 4em;
      height: 4em;
      object-fit: contain;
    }
    .icon-name {color: #666; word-break: break-word; font-size: 0.6em; }
    #loading { margin: 1em 0; }
    #loading p { margin: 0.25em 0; }
    /* Progressive loading stages (CSS-only timing) */
    #loading .loading-stage {
      opacity: 0;
      visibility: hidden;
      animation-name: showStage;
      animation-duration: 0s;
      animation-timing-function: step-end;
      animation-fill-mode: forwards;
    }
    #stage-1.loading-stage { animation-delay: 0s; }
    #stage-2.loading-stage { animation-delay: 3s; }
    #stage-3.loading-stage { animation-delay: 6s; }
    #stage-4.loading-stage { animation-delay: 12s; }
    @keyframes showStage {
      to {
        opacity: 1;
        visibility: visible;
      }
    }
    /* Error text is only shown when JS detects a failure */
    #error {
      display: none;
      color: #b00020;
      font-weight: 600;
    }
    #toc { margin: 1em 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <p><a href="index.html">‚Üê Max Bo</a></p>
  <h1>BeOS icons</h1>
  <p>Icons from the <a href="https://gitlab.com/metsatron/BeOS-r5-Icons">BeOS-r5-Icons</a> repository by <a href="https://gitlab.com/metsatron">Metsatron</a>.</p>
  <p>This collection includes original creations and adaptations by Metsatron, as well as icons from BeOS-r5, Zeta OS, Haiku OS, KDEclassic, OldGNOME2, Copland, and classic95 (Windows 95).</p>
  <details id="toc">
    <summary>Table of contents</summary>
    <ul id="toc-list"></ul>
  </details>
  <div id="loading">
    <p id="stage-1" class="loading-stage">Loading icons... (18.7 MB compressed, this may take a while)</p>
    <p id="stage-2" class="loading-stage">Yep still loading...</p>
    <p id="stage-3" class="loading-stage">STILL LOADING</p>
    <p id="stage-4" class="loading-stage">yep its still loading lol</p>
    <p id="error">Error loading icons: <span id="error-message"></span></p>
  </div>
  <div id="icons-container"></div>

  <script>
    // Manage loading errors (stages themselves are handled purely via CSS animations)
    const loadingError = document.getElementById('error');
    const loadingErrorMessage = document.getElementById('error-message');
    const loadingContainer = document.getElementById('loading');
    let loadingFailed = false;

    function showLoadingError(message) {
      loadingFailed = true;
      // Hide any staged messages and show the error instead
      document.querySelectorAll('#loading .loading-stage').forEach(el => {
        el.style.display = 'none';
      });
      if (loadingErrorMessage) {
        loadingErrorMessage.textContent = message;
      }
      if (loadingError) {
        loadingError.style.display = 'block';
      }
      if (loadingContainer) {
        loadingContainer.style.display = 'block';
      }
    }

    function loadingSucceeded() {
      if (loadingContainer) {
        loadingContainer.style.display = 'none';
      }
    }

    // Store unpacked files in memory
    const zipFiles = new Map();
    let zipLoaded = false;

    // Unpack zip file from array buffer
    async function unpackZip(arrayBuffer) {
      try {
        const zip = await JSZip.loadAsync(arrayBuffer);
        
        // Extract all files into memory
        const filePromises = [];
        zip.forEach((relativePath, file) => {
          if (!file.dir) {
            filePromises.push(
              file.async('blob').then(blob => {
                // Normalize path (remove leading directory if present, e.g., "BeOS-r5-Icons/")
                let normalizedPath = relativePath;
                // Remove leading slashes
                normalizedPath = normalizedPath.replace(/^\/+/, '');
                // Remove the root directory name if it matches common patterns
                const parts = normalizedPath.split('/');
                if (parts.length > 0 && (parts[0].includes('BeOS') || parts[0] === 'BeOS-r5-Icons' || parts[0] === 'BeOS-r5-Icons-master')) {
                  normalizedPath = parts.slice(1).join('/');
                }
                // Store both the normalized path and original path for lookup
                zipFiles.set(normalizedPath, blob);
                if (normalizedPath !== relativePath) {
                  zipFiles.set(relativePath, blob);
                }
              })
            );
          }
        });
        
        await Promise.all(filePromises);
        zipLoaded = true;
        
        // Log zip structure for debugging
        console.log('=== ZIP FILE STRUCTURE ===');
        console.log(`Total files in zip: ${zipFiles.size}`);
        const allPaths = Array.from(zipFiles.keys()).sort();
        console.log('All paths in zip:');
        allPaths.forEach(path => console.log(`  ${path}`));
        console.log('=== END ZIP STRUCTURE ===');

        loadingSucceeded();
        return true;
      } catch (error) {
        console.error('Error unpacking zip:', error);
        showLoadingError(`Failed to unpack zip file: ${error.message}`);
        return false;
      }
    }

    // Download and unpack the zip file
    async function loadZip() {
      try {
        // Try to load from a zip file - adjust the path as needed
        const zipUrl = 'BeOS-r5-Icons-master.zip';
        const response = await fetch(zipUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch zip: ${response.statusText}`);
        }
        const arrayBuffer = await response.arrayBuffer();
        return await unpackZip(arrayBuffer);
      } catch (error) {
        console.error('Error loading zip:', error);
        showLoadingError(`Failed to load zip file: ${error.message}`);
        return false;
      }
    }

    function getIconUrl(path) {
      const blob = zipFiles.get(path);
      if (blob) {
        return URL.createObjectURL(blob);
      }
      
      // Try case-insensitive search as fallback
      for (const [zipPath, zipBlob] of zipFiles.entries()) {
        if (zipPath.toLowerCase() === path.toLowerCase()) {
          return URL.createObjectURL(zipBlob);
        }
      }
      
      return '';
    }

    function createIconElement(path, name) {
      const iconItem = document.createElement('div');
      iconItem.className = 'icon-item';

      const img = document.createElement('img');
      const iconUrl = getIconUrl(path);
      if (iconUrl) {
        img.src = iconUrl;
        img.alt = name;
        // Extract size from path for data-size attribute
        const pathParts = path.split('/');
        if (pathParts.length >= 2) {
          const size = pathParts[pathParts.length - 2];
          img.setAttribute('data-size', size);
        }
        img.onerror = () => {
          // Hide broken images
          iconItem.style.display = 'none';
        };
      } else {
        // Hide if icon not found in zip
        iconItem.style.display = 'none';
        return null;
      }

      const label = document.createElement('div');
      label.className = 'icon-name';
      label.textContent = name;

      iconItem.appendChild(img);
      iconItem.appendChild(label);
      return iconItem;
    }

    function loadIconsForCategory(category, sizes) {
      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'category';

      const heading = document.createElement('h2');
      const categoryId = category.toLowerCase().replace(/\s+/g, '-');
      heading.id = categoryId;
      heading.textContent = category;
      categoryDiv.appendChild(heading);

      const numericSizes = Object.keys(sizes).filter(s => /^\d+$/.test(s)).sort((a, b) => parseInt(a) - parseInt(b));
      const otherSizes = Object.keys(sizes).filter(s => !/^\d+$/.test(s)).sort();

      [...numericSizes, ...otherSizes].forEach(size => {
        const sizeLabel = document.createElement('h3');
        const sizeId = `${categoryId}-${size}`;
        sizeLabel.id = sizeId;
        sizeLabel.textContent = `${size}x${size}`;
        categoryDiv.appendChild(sizeLabel);

        const iconGrid = document.createElement('div');
        iconGrid.className = 'icon-grid';

        sizes[size].forEach(icon => {
          const element = createIconElement(icon.path, icon.name);
          if (element) {
            iconGrid.appendChild(element);
          }
        });

        categoryDiv.appendChild(iconGrid);
      });

      document.getElementById('icons-container').appendChild(categoryDiv);
    }

    // Discover icons from zip file structure
    function discoverIconsFromZip() {
      const iconMap = {}; // { category: { size: [{ name, path }] } }

      console.log('=== DISCOVERING ICONS FROM ZIP ===');
      console.log(`Processing ${zipFiles.size} files from zip`);

      // Process all files in the zip
      for (const [path, blob] of zipFiles.entries()) {
        // Skip non-image files
        if (!/\.(png|gif|jpg|jpeg|svg|ico|webp)$/i.test(path)) {
          continue;
        }

        const parts = path.split('/').filter(p => p.length > 0);
        if (parts.length < 2) continue; // Need at least category/size/filename

        let category, size, name;

        // Handle extras/misc structure: extras/misc/subcat/filename.ext
        if (parts[0] === 'extras' && parts[1] === 'misc' && parts.length >= 4) {
          category = 'extras';
          size = `misc-${parts[2]}`;
          name = parts.slice(3).join('/').replace(/\.[^/.]+$/, ''); // Remove extension
        }
        // Handle scalable structure: scalable/size/filename.ext
        else if (parts[0] === 'scalable' && parts.length >= 3) {
          category = 'scalable';
          size = parts[1];
          name = parts.slice(2).join('/').replace(/\.[^/.]+$/, ''); // Remove extension
        }
        // Handle standard structure: category/size/filename.ext
        else if (parts.length >= 3) {
          category = parts[0];
          size = parts[1];
          name = parts.slice(2).join('/').replace(/\.[^/.]+$/, ''); // Remove extension
        } else {
          continue;
        }

        // Initialize category if needed
        if (!iconMap[category]) {
          iconMap[category] = {};
        }
        // Initialize size if needed
        if (!iconMap[category][size]) {
          iconMap[category][size] = [];
        }

        // Add icon if not already present (avoid duplicates)
        const exists = iconMap[category][size].some(icon => icon.name === name && icon.path === path);
        if (!exists) {
          iconMap[category][size].push({ name, path });
        }
      }

      // Sort icons by name within each size
      Object.keys(iconMap).forEach(category => {
        Object.keys(iconMap[category]).forEach(size => {
          iconMap[category][size].sort((a, b) => a.name.localeCompare(b.name));
        });
      });

      return iconMap;
    }

    // Build table of contents
    function buildTableOfContents(iconMap) {
      const tocList = document.getElementById('toc-list');
      tocList.innerHTML = '';
      
      Object.keys(iconMap).sort().forEach(category => {
        const categoryLi = document.createElement('li');
        const categoryId = category.toLowerCase().replace(/\s+/g, '-');
        const categoryLink = document.createElement('a');
        categoryLink.href = `#${categoryId}`;
        categoryLink.textContent = category;
        categoryLi.appendChild(categoryLink);
        
        // Add nested list for sizes
        const sizesUl = document.createElement('ul');
        const numericSizes = Object.keys(iconMap[category]).filter(s => /^\d+$/.test(s)).sort((a, b) => parseInt(a) - parseInt(b));
        const otherSizes = Object.keys(iconMap[category]).filter(s => !/^\d+$/.test(s)).sort();
        
        [...numericSizes, ...otherSizes].forEach(size => {
          const sizeLi = document.createElement('li');
          const sizeId = `${categoryId}-${size}`;
          const sizeLink = document.createElement('a');
          sizeLink.href = `#${sizeId}`;
          sizeLink.textContent = `${size}x${size}`;
          sizeLi.appendChild(sizeLink);
          sizesUl.appendChild(sizeLi);
        });
        
        categoryLi.appendChild(sizesUl);
        tocList.appendChild(categoryLi);
      });
    }

    // Load icons from zip file structure
    function loadIcons() {
      const iconMap = discoverIconsFromZip();
      
      // Build table of contents first
      buildTableOfContents(iconMap);
      
      Object.keys(iconMap).sort().forEach(category => {
        loadIconsForCategory(category, iconMap[category]);
      });
    }

    // Load zip first, then load icons
    loadZip().then(success => {
      if (success) {
        loadIcons();
      }
    });
  </script>
</body>
</html>
