<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Off-label GF2P8AFFINEQB</title>

  <style>
    @import url('../../stylesheets/fonts.css');
    @import url('./gf2p8affineqb-visualizer.css');

    body {
      font-family: 'Happy Times at the IKOB', 'Times New Roman', serif;
      max-width: 800px;
      background-color: #cecece;
      margin: 0 auto;
      color: rgb(30, 20, 77);
      /* font-family: 'Xanh Mono', serif; */
      padding: 20px;
    }

    blockquote {
      border-left: 1px solid red;
      padding-left: 20px;
      margin-left: 0;
    }


    pre {
      background-color: #f4f4f4;
      padding: 10px;
      overflow-x: auto;
    }

    table {
      border-collapse: collapse;
    }

    table,
    th,
    td {
      border: 1px solid rgb(30, 20, 77);
    }

    td,
    th {
      padding: 8px;
      text-align: center;
    }

    th {
      background-color: #ddd;
    }
  </style>
</head>

<body>

  <main>

    <p>
      <a href="../index.html">← Max Bo</a>
    </p>

    <h1>Off-label GF2P8AFFINEQB</h1>

    <time datetime="2025-12-21"><i>December 21, 2025</i></time>

    <p>
      Often used as a way to take the piss out of CISC ISAs, <a
        href="https://www.felixcloutier.com/x86/gf2p8affineqb">GF2P8AFFINEQB</a>, the Galois Field Affine
      Transformation, part of the <a href="https://en.wikipedia.org/wiki/AVX-512#GFNI">"Galois Field New Instructions"
        x86 extension</a>, has intruiged me for a while now.

      Unlike <a href="https://www.felixcloutier.com/x86/gf2p8affineinvqb">GF2P8AFFINEINVQB</a> and <a
        href="https://www.felixcloutier.com/x86/gf2p8mulb">GF2P8MULB</a>,
      which have more obvious relevance for performing the <a
        href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-box</a> and <a
        href="https://en.wikipedia.org/wiki/Rijndael_MixColumns">Rijndael MixColumns</a> steps of <a
        href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> respectively, GF2P8AFFINEQB is a
      little more general-purpose, finding "off-label" usage outside of cryptography.
    </p>

    <h2>What is a Galois field?</h2>

    <p>
      Intel's
      <a
        href="https://builders.intel.com/docs/networkbuilders/galois-field-new-instructions-gfni-technology-guide-1-1639042826.pdf">
        Galois Field New Instructions (GFNI) Technology Guide
      </a> gives a rather succinct definition:

    </p>
    <blockquote>
      A Galois Field is a field containing a finite number of elements. As with other fields, a Galois Field has well
      defined elements, and
      operations for addition, subtraction, and so on, when applied to those elements generates a result in the same
      field. The <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>GF</mi>
        <mo>(</mo>
        <mn>2</mn>
        <mo>)</mo>
      </math> field
      is simply a Galois Field with only two elements – 0 and 1. The addition of two values in <math
        xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>GF</mi>
        <mo>(</mo>
        <mn>2</mn>
        <mo>)</mo>
      </math> is equivalent to addition-modulo-2, or
      an exclusive-OR. The multiplication of two values in <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>GF</mi>
        <mo>(</mo>
        <mn>2</mn>
        <mo>)</mo>
      </math> is equivalent to multiplication-modulo-2, or the logical AND operation.

    </blockquote>


    <div style="display: flex; gap: 20px; justify-content: center;">
      <table>
        <tr>
          <th>+</th>
          <th>0</th>
          <th>1</th>
        </tr>
        <tr>
          <th>0</th>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1</td>
          <td>0</td>
        </tr>
      </table>

      <table>
        <tr>
          <th>×</th>
          <th>0</th>
          <th>1</th>
        </tr>
        <tr>
          <th>0</th>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>1</td>
        </tr>
      </table>
    </div>

    <h2>What does GF2P8AFFINEQB do?</h2>

    <p>
      The GF2P8AFFINEQB instruction performs an affine transformation in <math
        xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>GF</mi>
        <mo>(</mo>
        <msup>
          <mn>2</mn>
          <mn>8</mn>
        </msup>
        <mo>)</mo>
      </math>. For this instruction, an affine transformation is defined by <math
        xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>A</mi>
        <mo>⋅</mo>
        <mi>x</mi>
        <mo>+</mo>
        <mi>b</mi>
      </math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>A</mi>
      </math> is an 8 by 8 bit matrix, and <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>x</mi>
      </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mi>b</mi>
      </math> are 8-bit vectors.
    </p>

    Note that

    <blockquote>
      [i]n typical matrix fashion, each of the rows of the matrix determines how the resulting bits of the new 8-bit
      integer is defined. The bytes are defined in reverse order though, as the definition of the function defines its
      byte-indexing in reverse(7 - i) order. Byte 0 defines how bit-7 is built, byte 1 defines how bit-6 is built, byte
      2 defines how bit-5 is built, and so on.

      <div style="text-align: right; display: block;">
        — Wunk, <a href="https://wunkolo.github.io/post/2020/11/gf2p8affineqb-bit-reversal/"><cite>gf2p8affineqb: Bit
            reversal</cite></a>
      </div>
    </blockquote>

    <p>
      The visualizations' matrices' below are <i>unreversed</i> for clarity,
      but with the example code bit-shifting configured such that the
      matrix bitpattern is is in the reserved order that GF2P8AFFINEQB expects.
    </p>

    <h3>Identity transformation</h3>
    <div id="viz-identity" class="simulator-container"></div>

    <h3>Bit reversal</h3>
    <div id="viz-bit-reversal" class="simulator-container"></div>

    <h3>5-bit sign extension</h3>
    <div id="viz-sign-extension" class="simulator-container"></div>

    <script type="module">
      import { createVisualization, matrixToSrc2 } from './gf2p8affineqb-visualizer.js';

      const identityMatrix = 0x0102040810204080n;
      const identitySrc1 = new Uint8Array(16);
      identitySrc1[0] = 0b10110011;
      const identitySrc2 = matrixToSrc2(identityMatrix);

      createVisualization(
        document.getElementById('viz-identity'),
        identitySrc1,
        identitySrc2,
        0x00
      );

      // Bit reversal
      const reversalMatrix = 0x8040201008040201n;
      const reversalSrc1 = new Uint8Array(16);
      reversalSrc1[0] = 0b10101100;
      const reversalSrc2 = matrixToSrc2(reversalMatrix);

      createVisualization(
        document.getElementById('viz-bit-reversal'),
        reversalSrc1,
        reversalSrc2,
        0x00
      );

      // Sign extension
      const signExtMatrix = 0x0102040810101010n;
      const signExtSrc1 = new Uint8Array(16);
      signExtSrc1[0] = 0b00010010;
      const signExtSrc2 = matrixToSrc2(signExtMatrix);

      createVisualization(
        document.getElementById('viz-sign-extension'),
        signExtSrc1,
        signExtSrc2,
        0x00
      );
    </script>

    <h2>Usage in the real world</h2>


    <p>
      Through GitHub searches I found that <a href="https://wunkolo.github.io/about/">Wunkolo</a>,
      author of <a href="https://wunkolo.github.io/post/2020/11/gf2p8affineqb-int8-shifting/">
        <cite>gf2p8affineqb: Int8 shifting</cite>
      </a> and <a href="https://wunkolo.github.io/post/2020/11/gf2p8affineqb-bit-reversal/">
        <cite>gf2p8affineqb: Bit reversal</cite>
      </a>, submitted optimizations to Ymir, a Sega Saturn emulator (<a
        href="https://github.com/StrikerX3/Ymir/pull/183">1</a>),
      and Xenia, an Xbox 360 emulator (<a href="https://github.com/xenia-project/xenia/pull/1934">1</a>),
      (<a href="https://github.com/xenia-project/xenia/pull/1963">2</a>), (<a
        href="https://github.com/xenia-project/xenia/pull/1991">3</a>).
      has contributed to several projects utilizing GF2P8AFFINEQB.
    </p>


    <a href="https://gist.github.com/animetosho/d3ca95da2131b5813e16b5bb1b137ca0">
      Unexpected Uses for the Galois Field Affine Transformation Instruction
    </a>

    <br />

    <a href="https://stackoverflow.com/questions/59124720/what-are-the-avx-512-galois-field-related-instructions-for">
      What are the AVX-512 Galois-field-related instructions for?
    </a>

    <h3>Reed-Solomon error correction</h3>

    <a href="https://github.com/klauspost/reedsolomon">klauspost/reedsolomon</a>
    <a href="https://github.com/search?q=repo%3Aklauspost%2Freedsolomon%20GF2P8AFFINEQB&type=code">
      https://github.com/search?q=repo%3Aklauspost%2Freedsolomon%20GF2P8AFFINEQB&type=code
    </a>

    <h3>PS3 Cell floating point emulation</h3>

    <p>
      The PS3's Cell processor's <a
        href="https://www.copetti.org/writings/consoles/playstation-3#architecture-of-the-spu">SPU</a> does not use
      IEEE 754 floating point: it uses a custom floating point format, nicknamed "Xfloat" by the RPCS3 community:
    </p>

    <figure>
      <a
        href="https://archive.fosdem.org/2022/schedule/event/ps3/attachments/slides/5257/export/events/attachments/ps3/slides/5257/slides.pdf">
        <img src="./Xfloat.png" style="max-width: 100%; height: auto;"
          alt="Slide showing RPCS3 emulator's approach to floating-point accuracy. Title reads 'RPCS3 > CPU > SPU'. Content describes optional solutions to edge cases for accurate vs approximate xfloat modes. Accurate Xfloat emulates non-IEEE F32 behavior using ±smax-clamp and round-to-zero by: 1) Extending sign/exponent/mantissa bits from U32[4] to F64[4], 2) Doing the operation on AVX2/YMMI, 3) Bitcasting/truncating back to U32[4] with clamping and rounding. Approximate Xfloat uses <smin for math operations by applying clamps and setting denorms to 0, and for comparisons by bitcasting to integer. Right side shows God of War 3 gameplay comparison between ASMJIT (FPS: 12.02) and LLVM (FPS: 25.28) with caption thanking Nekotekina as accurate xfloat setting is no longer needed for most games with SPU LLVM Recompiler issues. Source cited as RPCS3 YouTube channel.">
      </a>
      <figcaption>
        Alexandro Sanchez Bach,
        <a
          href="https://archive.fosdem.org/2022/schedule/event/ps3/attachments/slides/5257/export/events/attachments/ps3/slides/5257/slides.pdf">
          <cite>
            PlayStation 3 Emulation
            (Re)implementing the impossible
          </cite>
        </a>
      </figcaption>
    </figure>
    </p>

    <p>
      We can take a look at the
      <a href="./SPU_ISA_v1.2_27Jan2007_pub.pdf">IBM Synergistic Processor Unit Instruction Set Architecture</a>
      documentation for more detail:
    </p>


    <style>
      blockquote.ibm {
        font-family: Arial, sans-serif;
        padding: 20px;
        background-color: #f5f5f5;
      }

      blockquote.ibm table {
        border-collapse: collapse;
        width: 100%;
        background-color: white;
      }

      blockquote.ibm th,
      blockquote.ibm td {
        border: 2px solid #4a90e2;
        padding: 3px;
        text-align: center;
      }

      blockquote.ibm th {
        background-color: #e3f2fd;
        font-weight: bold;
      }

      blockquote.ibm .header-row {
        background-color: #e3f2fd;
      }

      blockquote.ibm .notes-section {
        background-color: #e3f2fd;
        text-align: left;
        padding: 5px;
      }

      blockquote.ibm .notes-section ul {
        margin: 10px 0;
        padding-left: 20px;
      }

      blockquote.ibm sup {
        font-size: 0.7em;
      }
    </style>

    <blockquote class="ibm">

      For single-precision operations, the range of normalized numbers is extended. However, the full range
      defined in the standard is not implemented. 
      The range of nonzero numbers that can be represented and
operated on in the SPU is between the minimum and maximum listed in <i>Table 9-1</i>. <i>Table 9-1</i> also demonstrates converting from a register value to a decimal value.

<br />
<br />

      <i>Table 9-1. Single-Precision (Extended-Range Mode) Minimum and Maximum Values</i>
      <table>
        <thead>
          <tr class="header-row">
            <th>Number Format</th>
            <th colspan="3">Minimum Positive<br>Magnitude (Smin)</th>
            <th colspan="3">Maximum Positive<br>Magnitude (Smax)</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Register Value</strong></td>
            <td colspan="3">0x00800000</td>
            <td colspan="3">0x7FFFFFFF</td>
            <td></td>
          </tr>
          <tr>
            <td><strong>Bit Fields</strong></td>
            <td>Sign</td>
            <td>8-Bit Biased<br>Exponent</td>
            <td>Fraction (implied<br>[1] and 23 bits)</td>
            <td>Sign</td>
            <td>8-Bit Biased<br>Exponent</td>
            <td>Fraction (implied<br>[1] and 23 bits)</td>
            <td>1</td>
          </tr>
          <tr>
            <td></td>
            <td>0</td>
            <td>00000001</td>
            <td>[1.]000...000</td>
            <td>0</td>
            <td>11111111</td>
            <td>[1.]111...111</td>
            <td></td>
          </tr>
          <tr>
            <td><strong>Value in Powers of 2</strong></td>
            <td>+</td>
            <td>2<sup>(1 - 127)</sup></td>
            <td>1</td>
            <td>+</td>
            <td>2<sup>(255 - 127)</sup></td>
            <td>2 - 2<sup>-23</sup></td>
            <td>2</td>
          </tr>
          <tr>
            <td><strong>Combined Exponent and Fraction</strong></td>
            <td colspan="3">2<sup>-126</sup> * (+1)</td>
            <td colspan="3">2<sup>128</sup> * (+[2 - 2<sup>-23</sup>])</td>
            <td></td>
          </tr>
          <tr>
            <td><strong>Value of Register in Decimal</strong></td>
            <td colspan="3">1.2 * 10<sup>-38</sup></td>
            <td colspan="3">6.8 * 10<sup>38</sup></td>
            <td></td>
          </tr>
          <tr>
            <td colspan="8" class="notes-section">
              <strong>Notes:</strong>
              <ol>
                <li>The exponent field is biased by +127.</li>
                <li>The value 2 - 2<sup>-23</sup> is one least significant bit (LSb) less than 2.</li>
              </ol>
            </td>
          </tr>
        </tbody>
      </table>

    <br />

      Zero has two representations:
      <ul>
        <li>For a positive zero, all bits are zero; that is, the sign, exponent, and fraction are zero.</li>
        <li>For a negative zero, the sign is one; that is, the exponent and fraction are zero.</li>
      </ul>
      As inputs, both kinds of zero are supported; however, a zero result is always a positive zero.
      <br />
      Single-precision operations in the SPU have the following characteristics:
      <ul>
        <li>Not a Number (NaN) is not supported as an operand and is not produced as a result.</li>
        <li>Infinity (Inf) is not supported. An operation that produces a magnitude greater than the largest number
          representable in the target floating-point format instead produces a number with the appropriate sign, the
          largest biased exponent, and a magnitude of all (binary) ones. It is important to note that the representation
          of
          Inf, which conforms to the IEEE standard, is interpreted by the SPU as a number that is smaller
          than the largest number used on the SPU.</li>
        <li>Denorms are not supported and are treated as zero. Thus, an operation that would generate a denorm
          under IEEE rules instead generates a positive zero. If a denorm is used as an operand, it is treated as a
          zero.</li>
        <li>The only supported rounding mode is truncation (toward zero).</li>
      </ul>
    </blockquote>
    <blockquote class="ibm">
      A different-from-IEEE exception indicates that the result produced with extended-range arithmetic could
      be different from the IEEE result. This occurs when one of the following conditions exists:
      <ul>
        <li>Any of the inputs or the result has a maximal exponent (IEEE arithmetic treats such an operand as
          NaN or Infinity; extended-range arithmetic treats them as normalized values.)</li>
        <li>Any of the inputs has a zero exponent and a nonzero fraction (IEEE arithmetic treats such an oper-
          and as a denormal number; extended-range arithmetic treats them as a zero.)</li>
        <li>An underflow occurs; that is, the result before rounding is different from zero and the result after
          rounding is zero.</li>
      </ul>
    </blockquote>

    <p>

    </p>

    <p>
      <a href="https://www.youtube.com/watch?v=19ae5Mq2lJE">Here's the video that discusses it</a>
    </p>

    <p>
      <a href="https://github.com/RPCS3/rpcs3/pull/8712/files">PR</a>
    </p>

    <p>
      <a href="https://github.com/RPCS3/rpcs3/pull/14669">another PR</a>
    </p>


    <p>
      <a
        href="https://github.com/Whatcookie/rpcs3/blob/732fd479121fe09587fb43fce0cebb55f085d5e7/rpcs3/Emu/Cell/SPURecompiler.cpp#L7284-L7340">Updated
        version</a>
    </p>

    <h3>Go GC</h3>

    <p>
      <a href="https://go.dev/blog/greenteagc">https://go.dev/blog/greenteagc</a>
    </p>

    <h2>What can we apply it to?</h2>

    <p>
      &lt;search for an application and get a speedup&gt;
    </p>

    https://gist.github.com/animetosho/d3ca95da2131b5813e16b5bb1b137ca0

    https://bitmath.blogspot.com/2023/04/not-transposing-16x16-bitmatrix.html


    https://github.com/riscv/riscv-bitmanip/wiki

    https://wunkolo.github.io/post/2020/11/gf2p8affineqb-bit-reversal/

    <a
      href="https://github.com/animetosho/ParPar/blob/master/fast-gf-multiplication.md#affine-transformation--bit-matrix-xor">
      i don't even fucking know man
    </a>


  </main>
</body>

</html>