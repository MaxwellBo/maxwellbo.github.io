<!DOCTYPE html>
<html>
<title>HaskellNotes</title>
<xmp theme="Readable" style="display:none;">
**__Resources__**

- [Learn You a Haskell](http://learnyouahaskell.com/)
- [The Haskell Prelude](https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html)

**__Notes__**

- Pattern matching is used for deconstruction and binding
    + You can pattern match in list comprehensions if you want
- `where`
    + serve as deconstructors / binders / helpers that would normally written first in an imperitive language
    + scoped to the entire function
    + can be nested. It's a common idiom to make a function and define some helper function in its where clause and then to give those functions helper functions as well, each with its own where clause.
    + is bound to a surrounding syntactic construct, like the pattern matching line of a function definition
    + can be multiple lines each defining the same thing, as these lines will pattern match
- `let <bindings> in <expression>`
    + scoped to the entire function, not including guards
    + let ... in ... is an expression, that is, it can be written wherever expressions are allowed.
    + puts the bindings first and the expression that uses them later whereas `where` is the other way around
    + Has crazy scoping rules
        * Automatically fills list comprehensions
        * Applies globally if not defined with an `in`
        * Can be applied locally to only certain expressions
            - `let boot x y z = x * y + z in boot 3 4 2`  
            - (which is why it doesn't scope to guards)
- Guards
    + If all the guards of a function evaluate to False (and we haven't provided an otherwise catch-all guard), evaluation falls through to the next pa`ttern
- `case expression of pattern -> result  `
    + Called case expressions because they're expressions
- Recursion
    + Use the base cases to build the construct you need
        * For example, the base cases contain the empty list that you append everything to
    + > The edge condition, as is most of the times with lists, is the empty list
    + Recursion almost always does something with the head, and if the condition isn't fulfilled, calls itself again on the tail
- Higher order functions
    + If our function requires us to pass it a function that takes only one parameter, we can just partially apply a function to the point where it takes only one parameter and then pass it.
    + The most common use case with flip is calling it with just the function parameter and then passing the resulting function on to a map or a filter.
        * use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter.
            - `flip' f = \x y -> f y x`
- Partial application is everywhere. Always check whether you need to specify a parameter
    + if you have a function like `foo a = bar b a` you can rewrite it as `foo = bar b`, because of currying.
- folds are, along with maps and filters, one of the most useful types of functions in functional programming.
- scan is a progressing fold
-  use takeWhile to cut the scanlist off at the first occurence of a sum greater than 1000.
- map function application over a list of functions.
    + map ($ 3) [(4+), (10*), (^2), sqrt]
    + "Raking over the coals"
- Good signature:
- 
```haskell
    + `(.) :: (b -> c) -> (a -> b) -> a -> c  
f . g = \x -> f (g x)
```

Places you can pattern match
- In `let` and `where` clauses
- List comprehensions
- `do` blocks
- [More](https://en.wikibooks.org/wiki/Haskell/Pattern_matching)
fn x = ceiling (negate (tan (cos (max 50 x))))  

fn = ceiling . negate . tan . cos . max 50

exposes the max function to partial application

```haskell
map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
```

- Bound variables "spread" themselves over pattern matches. The bound variable is the one that is typechecked, and the pattern matching catches the "value constructors"
    + "It's common to use the same name as the type if there's only one value constructor"
    + `surface (Rectangle (Point x1 y1) (Point x2 y2))` demonstrates pattern matching on multiple constructors
- If you want to pattern match on constructors, they have to be members of a datatype
    + "We pattern matched against constructors before (all the time actually) when we pattern matched against values like [] or False or 5, only those values didn't have any fields."
- Value constructors are just functions that take the fields as parameters and return a value of some type (like Shape) as a result


- `data Maybe a = Nothing | Just a  `
    + This is a type constructor
    + "No value can have a type of just Maybe, because that's not a type per se, it's a type constructor."
    + "Just 'a' has a type of Maybe Char"
    + "Notice that the type of Nothing is Maybe a. Its type is polymorphic. If some function requires a Maybe Int as a parameter, we can give it a Nothing, because a Nothing doesn't contain a value anyway and so it doesn't matter."
    + [Actually all of this is pretty interesting](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-parameters)

- `tellCar (Car {company = c, model = m, year = y})` Pattern matching on the constructor

- 'tellCar :: Car -> String' | `tellCar :: (Show a) => Car String String a -> String`
    + Notice the difference between a value constructor and a type constructor?
    + The second is an example of a Car type that has been changed through "parameterizing"
- Never add typeclass constraints in data declarations
-  When declaring a data type, the part before the = is the type constructor and the constructors after it (possibly separated by `|`s) are value constructors
    +   vector type constructor takes only one parameter, whereas the value constructor takes three

We introduce type synonyms either to describe what some existing type represents in our functions (and thus our type declarations become better documentation) or when something has a long-ish type that's repeated a lot (like [(String,String)]) but represents something more specific in the context of our functions.

Type synonyms can also be parameterized. If we want a type that represents an association list type but still want it to be general so it can use any type as the keys and values, we can do this:

`type AssocList k v = [(k,v)] `

Just like we can partially apply functions to get new functions, we can partially apply type parameters and get new type constructors from them.

Pattern matching is actually about pattern matching on constructors.

Type declarations can use constructors that return types.

`:` is actually a constructor that takes a vlue and another list and returns a list.

Pattern matching works (only) on constructs. We can match for stuff like constructors, normal prefix constructs of stuff like `8` or `'a'`, which are basically constructors fot the numeric and charachter types, respectively.


We did it by using the instance keyword. So class is for defining new typeclasses and instance is for making our types instances of typeclasses. When we were defining Eq, we wrote class Eq a where and we said that a plays the role of whichever type will be made an instance later on. We can see that clearly here, because when we're making an instance, we write instance Eq TrafficLight where. We replace the a with the actual type.

We implemented `==` by implementing functions the normal way, with pattern matching against the different variables for the `True` solutions (`Red == Red = True`). The type class resolves the `/=` operator with the `x /= y = not (x == y)` statement. 

Use `let` to modify single lines and inject information into statements

`let` scopes to the entire `do` block or list comprehension

Use `where` to modify entire blocks of code, and `let` for specific statements

Isolate IO to specific functions. If it has to be spread across multiple functions, isolate their calls into one do block for simplicity.

A type signature for the entire function can allow inference for `random`functions in the body. 

Use partial application so that functions don't have to recieve wrapped types, like `mkStdGen`

Type annotations can be used to describe what you want, rather than describing what you're going to get

Notice that we didn't have to do random gen :: (Bool, StdGen). That's because we already specified that we want booleans in the type declaration of the function. That's why Haskell can infer that we want a boolean value in this case.

Try to keep `main` as small as possible

Thunks (the technical term for promise)</xmp>
<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>
