<!DOCTYPE html>
<html>
<title>DatabaseNotes</title>
<xmp theme="Readable" style="display:none;">
### Module 2 ###

**__DFD Concepts__**

**Terminator**

- __Rectangle labelled with a noun__
- A external source / sink of information
- Must have at least one data flow entering or leaving


**Data flow**

- __Arrow labelled with a noun + possible objective__
- Carries data from one place in the system to the other
    + Must start or end at a process


**Processes**

- __Rectangle with rounded edges, ID code ontop, and a name underneath__
    + 0 is Context Level
    + 1.0, 2.0, 3.0 is Level 0
- An activity that can transform, generate, retrieve, or delete data
- Must have both incoming and outgoing dataflows


**Data Stores**

- __Rectangle with square edges, ID code left, and a filename right__
- Must connect only to processes
- Must have at least one incoming and one outgoing flow


**__DFD Rules__**

- The input of a process must be different from its outputs
- No process can have only inputs or only outputs
    + Processes must have both outputs and inputs
    + Process labels sdhould be verb phrases
- All flows to or from a data store must move through a process
    + Data store labels should be noun phrases
- No data moves directly between external entities without going through a process
    + Source and sink labels should be noun phrases
- Bidirectional flow between process and datastore is represented by two seperate arrows
- Forked data flow must refer to the same data item from a common location to multiple destinations
- Data flow cannot go directly from a process to itself - it must go through intervening processes
- __DFDs must be balanced__
    + Number of inputs to lower level DFD equals number of inputs to associated process of higher-level DFD
    + Number of outputs to lower level DFD equals number of outputs to proces of higher-level DFD
    + A composite data flow at a higher level may be split if different parts go to different processes in the lower level DFD


**__State Transition Diagrams (STD)__**
Finite state machine
- States + events which cause change of state

`(S1) -- E1[C1]/A1 --> (S2) -- E2[C2]/A2 --> (S3)`

System 1, when Event 1 and Condition 1 is true, is changed by Action 1 to System 2

S1 is an initial state, and S3 is a terminal state


**Rules**

1. All states must be defined
2. All states must be reachable
3. All states except for the final states must have exits


Thus, with this ruleset, events become DFD terminators. Processes pull forked dataflow triggers from datastores and abstract event terminators

---

### Module 3 ###

**__ER Concepts__**

**__Entity__**

- Real-world object distinguishable from other objects
- An entity is described using a set of attributes


**__Entity Sets__**

- __A table__
- A collection of similiar entities
- All entities in an entity set have the same set of attributes
- Each entity has a key
- Each attribute has a domain


**__Entity Type__**

- __A row in a table, as a class__
- Defines set of entities that have the same attributes
- Each entity is described by its NAME and and attributes
- The Entity Type describes the Schema or Intension for a set of entities
- Collections of all entities of a particular entity type at a given point in time is called the Entity Set or Extension of an Entity Type
- Entity Type and Entity Set are customarily referred to by the same name


**__Attributes__**

- Attribute with attributes forking off
    + Composite attributes can be divided into smaller parts which represent simple attributes with independent meaning
    + Aicraft-Location
        * Aircraft-Latitude
        * Aircraft-Longitude
        * Aircraft-Altitude
- Attribute with double line ring
    + Multivalued attribute
        * Name: Degree
        * Contents: `{BSc, MInfTech}`
- Attribute with dotted ring
    + Derived attributes can be derived from related attribute values
        *` Age --> Date - B-day`, where `Age` is the derived attribute


**__Representation__**

```SQL
{AddressPhone
            ({Phone (AreaCode,PhoneNum)},
            Address (StreetAddresss (Number, Street, AptNo),
                                    City,
                                    State,
                                    PostalCode))}
```

**Formal justification**

```SQL
A | A:E --> P(V)

where A is an attribute
where E is the Entity Type
where V is the Value Set
where P(V) is the Power Set of V
```

or

Value of attribute A for entity e is A(e), "attribute of entity", where e is an entity of type E

A is a Simple Attribute where A(e) is

- A singleton `{a}`` for single-valued attributes
- Not a singleton `{a, b, ..., n}` for multi-valued attributes
- An empty set `{}` for null valued attributes

A is a Composite Attribute when the value set V is the Cartesian product of sets:

`P(V1) * P(V2) ... * P(Vn)`, remembering that Vn are Simple Attributes

**Relationships**

A Relationship is an association among two or more entities

- A Relationship Type defines the relationship
    + A Relationship Type R defines a set of associations among `n` entity types, `E1, E2, ..., En`
    + `R` is a subset of the Cartesian Product `E1 X E2 X ... X En`
    + Each Entity Type is said to participate in the relationship Type
- A Relationship Set represents a set of relationship instances
    + A Relationship Set `R` is a set of relationship instances `ri`, where each `ri` associates `n` individual entities `(e1, e2, ..., en)`
    + Each `ei` is said to participate in the relationship instance


**Cardi-nality Ratios**

- (1:1)
    + Attributes of relationship on either side
- (1:N, N:1)
    + Attributes of relationship on N side
- (N:M)
    + Attributes of relationship in relationship table, as the attributes are determined by the combination of each entity
        * Example: `Store - <Keeps> - Product`, `qty` is an attribute of `<Keeps>`
        * Qty of Keeps can on ly be determined by the combination of `STORE` and `PRODUCT`


**Existence dependancy**

- Total participation `=`
    + Constraint: Every employee must work for a department
- Partial participation `-`
    + Constraint: Not every employee is a manager

```
Employees   ==N== Works_In  ==1==   Departments
            --1-- Manages   ==1==   
```

**Weak Entities**

- __Rectangles with double lines__
- Entity types that do not have key attributes of their own are called "Weak Entities"
- The relationship type that relates a weak entity to its owner is called the __"Identifying relationship"__, which is a __relationship with double lines__
 - Owner and weak entity must participate in a 1:N relationship type
 - Weak entity must have total participation `=` in the identifying relationship set (existence dependency)
 - Weak entities normally have a "Partial Key" which a set of attributes that uniquely identify weak entities related to the same owner entity


**Classes**

- `(O)` - overlapping, OR
- `(d)` - disjoint, XOR

```
EMPLOYEE === (d) --)-- HOURLY
                 --)-- SALARY
```

where `HOURLY` and `SALARY` are subclasses of `EMPLOYEE`     


---

### Module 4 ###

**__Relation components__**

- Relaton name
- Tuples
- Attribute names
- Attribute values from the same domain


**Domains**

- A Domain `D` a set of atomic values
    + Has a datatype / format


**Attributes**

- Each attribute `A` is the name of a role played by some domain `D` in the relation named `R`
- The number of attributes in a relation `R` is called the degree of `R`


**Tuples**

- Each Tuple `t` is an ordered list of n value:
    + `t = <v1, v2, ..., vn>`


**Relation Schema**

- Denoted by `R(A1, A2, A3, ... An)`, where `R` is the relation name, and `An` is attribute `n`
- Integer `n` is termed "degree of the relation"


**Relation Instance**

- A relation instance r of the relation scheme `R`, denoted by `r(R)` "`r of R`", is a set of n-tuples `r = {t1, t2, ..., tm}`

Thefore, *schema is a description of the relation* and *instance is the data within the relation*


**Constraints**

Catagories:

- Single relation
    + Domain
    + Key
    + Entity
- Multiple relation
    + Referential


**Superkey**

A superkey is a subset of attributes `(SK) `of a relation schema `R`, such that for any two tuples, `ti` and `tj` in a relation state `r` of `R`

`ti[SK] =/= tj[SK]`

Every relation has at least one superkey - the set of all its attributes

A superkey can have redundant attributes, that is, by removing some attributes, the uniqueness constraint is still maintained

**Notion of a key**
`K` is a key in a relation schema `R` if

- `K` is a Superkey of `R`
- Removing any attribute from K leaves a set of attributes `K'`, where `K'` is not a superkey of `R`, that is `K'` does NOT maintain the uniqueness constraint

Key is a minimial superkey: the smallest set of attributes that uniquely identify a tuple

A schema may have more than one key

- Each is called a "candidate" key
- One is slected as the "primary" key

**Foreign keys**
A set of attributes FK in relation schema R1 is a foreign key if

- the attributes of FK have the same domain as the primary key attributes P{K of another schema R2
- `t1[FK] = t2[PK]` or `t1[FK] `is `null`
- `FK` is said to "reference" `PK`

---

### Module 6 ###

Data in a relation database can be manipulated in the following ways:

`INSERT`: New tuples may be inserted
`DELETE`: Existing tuples may be deleted
`UPDATE`: Values of attributes in existing tuples may be changed
`RETRIEVE` Attributes of specific tuples, existing tuples, or even entire relations may be retrived


**__Syntax__**

__`KEYWORD argument [optional] {multiple} ...|..choice..|...`__

// TODO: Go to wikipedia for code snippets here


##`CREATE TABLE`

```SQL
CREATE TABLE Employees (ssn CHAR(11),
                        name CHAR(20),
                        sal INTEGER,
                        PRIMARY KEY (ssn))
```

```SQL
CREATE TABLE EMPLOYEE
    ( FNAME VARCHAR (15) NOT NULL,
        ...
    PRIMARY KEY (SSN)
    FOREIGN KEY (SUPERSSN) REFERENCES EMPLOYEE(SSN)
    FOREIGN KEY (DNO) REFERENCES DEPARTMENT (DNUMBER) );
    )
```


Constraints specified in the CREATE TABLE command can be given a command:
    `CONSTRAINT EMPPK PRIMARY KEY (SSN)`

A referential triggered action caluse can be attatched to a foreign key constraint that specifies the action to take if a referenced tuple is deleted, or a referenced primary key value is modified:
    `FOREIGN KEY (DNO) REFERENCES DEPARTMENT (DNUMBER) ON DELETE SET DEFAULT ON UPDATE CASCADE);`


**`ALTER TABLE`**

``` SQL
ALTER ABLE <table name>
    ADD column_name column_type [attribute_constraint] {column_name column_type [attribute_constraint]}

    DROP column_name [CASCADE]

    ALTER column_name column_options

    ADD constraint_name constraint_options

    DROP constraint_name [CASCADE];
```

To add an attribute (Value in all tuples will be initially NULL, so NOT NULL
cannot be specified)

•  Selection (`WHERE` clause)
    –  Horizontal scanner to select tuples from given collection of tuples
•  Projection (`SELECT` clause)
    –  Vertically select the attributes of given collection of tuples
•  Join (`FROM` clause)
    –  Combine tuples from different relations for the search purposes
•  Sorting (`ORDER` clause)
    –  Order the resulting tuples according to the given sort key


### Module 7 ###

Guidlines:

- Don't do stupid shit

**__Functional Dependency__**

- A functional dependency (FD) is a constraint denoted `X -> Y` between two sets of attributes X and Y from a relational schema R
- The FD specifies a restriction on the possible tuples that can form a relation instance r of `R`


**Informally**

`X -> Y` holds if and only if whenever two tuples agree on their `X`-value, they must necessarily agree on their Y value


**Formally**

The FD constraint is that for any two tuples t1 and t2 in the relation instance r that have:

```
t1[X] = t2[X]
t2[Y] = t2[Y]
```

This means that the values of the Y component of a tuple depend on, or are determined by the X component


**Applications of FDs**

Relation instances `r(R)` that satisfy the FD constraints are called legal extensions, legal instances or legal relation states]


**Notation for Inferred FDs**

The notation `F |= X ->` denotes that the FD `X -> Y` is inferred from the set of functional dependencies F

```SQL
F |= {  Pnum -> MgrStartDate,
        Dnum -> MgrSSN,
        Pnum -> Pnum}

where F = { Pnum -> {Pname, Plocation, Dnum},
            Dnum -> {Dname, MgrSSN, MgrStartDate}
            {ESSN, DependenT_Name} -> BDate}

P -> NLD
D -> MGS
ET -> B
```


Inference rules
- The set of all dependencies that can be inferred from a given F is called the closure of F, denoted by F+

**IR1: Reflexive Rule**

If `Y ⊆ X`, then `X -> Y`

If `ESSN ⊆ {ESSN, Dependent_Name}` then
`{ESSN, Dependent_Name} -> ESSN` holds

A set of attributes always determines itself or any of its subsets


**IR2: Augmentation Rule**

`{X -> Y} |= {XZ -> YZ}`

If `SSN -> Ename` then
`{SSN, Address} -> {Ename, Address}` holds

Adding the same set of attributes to both the LHS & RHS of a FD results in
another valid FD


**IR3: Transitive Rule**

`{X -> Y, Y -> Z} |= X -> Z`

If` SSN -> Dno`
and `Dno -> Dlocation`
then `SSN -> Dlocation` holds


**IR4: Decomposition Rule**

`{X -> YZ} |= X -> Y`

If `SSN -> Ename`, Dno
then `SSN -> Ename` and `SSN -> Dno` both hold

We can remove attributes from the RHS of a dependency, and
decompose the FD


**IR5: Union Rule**

`{X -> Y, X -> Z} |= X -> YZ}`

If `SSN -> Ename` and `SSN -> Dno`
then `SSN -> Ename, Dno`
holds

We can union attributes from the RHS of a dependency, and combine
a set of FDs into a single FD (reverse of IR4)


**IR6: Pseudotransitive Rule**

`{X -> Y, WY -> Z} |= WX -> Z`

If `SSN -> MgrSSN` and
`MgrSSN, Dependent_Name -> Relationship`
then `SSN, Dependent_Name -> Relationship`

**Closure**

`X+` is the closure of `X` under the set `F`, where `X` is a set of attributes


**__Normalization__**

- Superkey - A set of attributes such that no two tuples have the same values for these attributes
- Key - A Minimal Superkey, called a Candidate Key if more than one
    + Primary key - A selected candidate key
    + Secondary key - Remaining candidate keys
- Prime Attribute - An attribute that is a member of any candidate key
- Non-prime attribute - An attribute that is not a member of any candidate key


**First Normal Form (1NF)**

A relation schema is in 1NF if domains of attributes include only atomic (simple, indivisible) values and the value of an attribute is a single value from the domain of that attribute

*1NF disallows*

–  having a set of values, a tuple of values, or a combination of both as an attribute value for a single tuple
–  "relations within relations" and "relations as attributes of tuples"


**Second Normal Form (2NF)**

A relation schema is in 2NF if it is in 1NF, and every non-prime attribute is fully functionally dependent on every key

A FD `X -> Y` is termed “full” if removal of any attribute from `X` means that the FD no longer holds.

Formally, for any attribute, if `A ∈ X, (X-{A}) -> Y` is `false`

```SQL 
NO
DEP [SSN, Dep_Name, Dep_Bdate, Emp_Bdate]
FD1: {SSN, Dep_Name} -> Dep_Bdate
FD2: SSN -> Emp_Bdate

YES
EMP [SSN, Emp_Bdate]
NEW-DEP [SSN,Dep_Name, Dep_Bdate]
```


**Third Normal Form (3NF)**

A relation schema is in 3NF if it is in 2NF, and no non-prime attribute is transitively dependent on every key

A FD `X -> Y `is termed “transitive” if there is a set of attributes `Z` that is not a subset of any key and both `X -> Z` and `Z -> Y` hold

```SQL
NO
EMP[Name, State, Code]
FD1: NAME -> {STATE, CODE}
FD2: CODE -> STATE

YES
EMP-CODE [Name, Code]
STATE-CODE [State, Code]
```

---</xmp>
<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>
