<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="main.css" rel="stylesheet">
  <meta charset="UTF-8">
  <title>A HTML file is all you need</title>
</head>

<body>
  <main>
    <header>
      <nav>
        <h2>
          <marquee>
            <a href="/">‚Üê Max Bo</a>
          </marquee>
        </h2>
      </nav>
      <h2>Can we build a reactive document in a single HTML file?</h2>
    </header>

    <b>Yes</b> <i><sub>(by standing on the shoulders of <a href="https://observablehq.com/">Observable</a>)</sub></i>.

    <br />
    <br />

    First, we'll steal a trick from <a href="https://secretgeek.github.io/html_wysiwyg/html.html">This page is a
      truly naked, brutalist html quine</a>,
    and we'll create a <code>echo</code> class that will let us display
    <code>style</code> and <code>script</code> tags inline.
    This doesn't perfectly quine/echo all the source HTML to the DOM, so <kbd>View source</kbd> to see the "real"
    HTML - note the <code>id</code>s of the <code>script</code> blocks.

    <style class="echo">
      .echo {
        display: block;
        white-space: pre;
        font-family: monospace;
        background-color: #EEE;
        margin: .2rem;
        overflow: scroll;
      }
    </style>

    Then we'll import the <a href="https://github.com/observablehq/stdlib">Observable standard library</a> and <a
      href="https://github.com/observablehq/runtime">Observable runtime</a>, and bind them to the global window
    context. We'll define helper methods <code>cell</code> and <code>observer</code> that wrap some of the runtime API.

    <script type="module" class="echo">
      import * as stdlib from 'https://esm.run/@observablehq/stdlib'
      import { Runtime, Inspector } from "https://esm.run/@observablehq/runtime";

      const library = new stdlib.Library();
      const runtime = new Runtime();
      const module = runtime.module();

      function cell(name, inputsOrDefinition, maybeDefinition) {
        if (maybeDefinition) {
          const inputs = inputsOrDefinition
          const definition = maybeDefinition
          module.variable(observer(name)).define(name, inputs, definition)
        } else {
          const definition = inputsOrDefinition
          module.variable(observer(name)).define(name, definition)
        }
      }

      function observer(cellName) {
        const div = document.createElement("div");
        const cellElement = document.getElementById(cellName)
        cellElement.parentNode.insertBefore(div, cellElement);
        return new Inspector(div);
      }

      window.library = library
      window.module = module
      window.cell = cell
      window.observer = observer
    </script>

    Now we declare a cell called <code>counter</code> that will emit a number every second.
    We have to declare the <code>script</code> tag with <code>type="module" class="echo" id="counter"</code>.
    <b>The <code>script</code> <code>id</code> must be the same as the cell name.</b>

    <script type="module" class="echo" id="counter">
      cell("counter", async function* () {
        let i = 0
        while (true) {
          yield await library.Promises.delay(1000, i++)
        }
      });
    </script>

    Now we've created a our <code>counter</code> cell, we can create other cells that depend on it.

    <br />

    Let's import <a href="https://github.com/observablehq/htl">Hypertext Literal</a> and use it to format the
    <code>counter</code> value.

    <script type="module" class="echo" id="fizzbuzz">
      import * as htl from 'https://esm.run/htl'

      cell("fizzbuzz", ["counter"], (counter) => {
        if (counter % 3 === 0 && counter % 5 === 0) {
          return htl.html`<span style="color: purple">FizzBuzz</span>`
        } else if (counter % 3 === 0) {
          return htl.html`<span style="color: red">Fizz</span>`
        } else if (counter % 5 === 0) {
          return htl.html`<span style="color: blue">Buzz</span>`
        } else {
          return htl.html`<span>${counter}</span>`
        }
      });
    </script>

    Let's import <a href="https://github.com/observablehq/plot">Observable Plot</a> and use the <code>counter</code>
    value in the plot.

    <script type="module" class="echo" id="plot">
      import * as Plot from 'https://esm.run/@observablehq/plot'

      cell("plot", ["counter"], (counter) => {
        const numbers = [
          170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
          176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
          166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
          163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
        ]
        return Plot.plot({
          marks: [
            Plot.lineY(numbers, { x: (d, i) => i, y: d => d }),
            Plot.ruleX([counter % 40])
          ]
        })
      });
    </script>

    <h3>Inputs</h3>

    <p>We'll create a new cell type <code>viewof</code> that works specifically with <a
        href="https://github.com/observablehq/inputs">Observable
        Inputs</a>.

      It declares 2 reactive cells: <code>NAME</code> and <code>viewof NAME</code> - one for the value, and one for the
      DOM element itself.

      <script type="module" class="echo">
        function viewof(name, inputsOrDefinition, maybeDefinition) {
          if (maybeDefinition) {
            const inputs = inputsOrDefinition
            const definition = maybeDefinition
            module.variable(observer(name)).define("viewof " + name, inputs, definition)
            module.variable().define(name, ["viewof " + name], (inpt) => library.Generators.input(inpt))
          } else {
            const definition = inputsOrDefinition
            module.variable(observer(name)).define("viewof " + name, definition)
            module.variable().define(name, ["viewof " + name], (inpt) => library.Generators.input(inpt))
          }
        }
        window.viewof = viewof
      </script>

      <script type="module" class="echo" id="range">
        import * as Inputs from 'https://esm.run/@observablehq/inputs'

        viewof("range", () => {
          return Inputs.range([0, 100], { step: 1 })
        });
      </script>

      <script type="module" class="echo" id="rangePlot">
        import * as Plot from 'https://esm.run/@observablehq/plot'

        cell("rangePlot", ["range"], (range) => {
          return Plot.tickX([range]).plot({ x: { domain: [0, 100] } })
        });
      </script>

  </main>
</body>

</html>