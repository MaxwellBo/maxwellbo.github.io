<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="main.css" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="description" content="Yes (by standing on the shoulders of Observable)">
  <meta name="author" content="Max Bo">
  <title>Can we build a reactive document in a single HTML file?</title>
</head>

<body>
  <main>
    <header style="padding-bottom: 1rem">
      <nav>
        <h2>
          <marquee>
            <a href="/">← Max Bo</a>
          </marquee>
        </h2>
      </nav>
      <time datetime="2024-05-06">May 6, 2024</time>
      <h1>Can we build a reactive document in a single HTML file?</h1>
      <b>Yes</b> <i><sub>(by standing on the shoulders of <a href="https://observablehq.com/">Observable</a>)</sub></i>.
    </header>


    First, we'll steal a trick from <a href="https://secretgeek.github.io/html_wysiwyg/html.html">This page is a
      truly naked, brutalist html quine</a>,
    and create a CSS class called <code>echo</code> that will display
    <code>style</code> and <code>script</code> elements inline.
    <code>echo</code> doesn't perfectly quine/echo all the source HTML to the DOM, so you'll need to use <kbd>View source</kbd> to see the "real"
    HTML - note the <code>id</code> attributes of the <code>script</code> elements.

    <style class="echo">
      .echo {
        display: block;
        white-space: pre;
        font-family: monospace;
        background-color: #EEE;
        margin: .2rem;
        overflow: scroll;
      }
    </style>

    Now we'll import the <a href="https://github.com/observablehq/stdlib">Observable standard library</a> and the <a
      href="https://github.com/observablehq/runtime">Observable runtime</a>, and bind them to <code>window</code> We'll define helper methods <code>cell</code> and <code>observer</code> that wrap some of the runtime API.

    <script type="module" class="echo">
      import * as stdlib from 'https://esm.run/@observablehq/stdlib'
      import { Runtime, Inspector } from "https://esm.run/@observablehq/runtime";

      const library = new stdlib.Library();
      const runtime = new Runtime();
      const module = runtime.module();

      function cell(name, inputsOrDefinition, maybeDefinition) {
        if (maybeDefinition) {
          const inputs = inputsOrDefinition
          const definition = maybeDefinition
          module.variable(observer(name)).define(name, inputs, definition)
        } else {
          const definition = inputsOrDefinition
          module.variable(observer(name)).define(name, definition)
        }
      }

      function observer(cellName) {
        const div = document.createElement("div");
        const cellElement = document.getElementById(cellName)
        cellElement.parentNode.insertBefore(div, cellElement);
        return new Inspector(div);
      }

      window.library = library
      window.module = module
      window.cell = cell
      window.observer = observer
    </script>

    Now we'll declare a cell called <code>counter</code> that will emit a number every second.
    We have to declare the <code>script</code> element with attributes <code>type="module" class="echo" id="counter"</code>.
    <b>The <code>script</code> <code>id</code> attribute must be the same as the <code>name</code> parameter passed to <code>cell</code></b>.

    <script type="module" class="echo" id="counter">
      cell("counter", async function* () {
        let i = 0
        while (true) {
          yield await library.Promises.delay(1000, i++)
        }
      });
    </script>

    Now that we've created a our <code>counter</code> cell, we can create other cells that depend on it.

    <br />

    We'll import <a href="https://github.com/observablehq/htl">Hypertext Literal</a> and use it to format the
    <code>counter</code> value.

    <script type="module" class="echo" id="fizzbuzz">
      import * as htl from 'https://esm.run/htl'

      cell("fizzbuzz", ["counter"], (counter) => {
        if (counter % 3 === 0 && counter % 5 === 0) {
          return htl.html`<b style="color: purple">FizzBuzz</b>`
        } else if (counter % 3 === 0) {
          return htl.html`<b style="color: red">Fizz</b>`
        } else if (counter % 5 === 0) {
          return htl.html`<b style="color: blue">Buzz</b>`
        } else {
          return htl.html`<b>${counter}</b>`
        }
      });
    </script>

    We'll import <a href="https://github.com/observablehq/plot">Observable Plot</a> and use the <code>counter</code>
    value in the plot.

    <script type="module" class="echo" id="plot">
      import * as Plot from 'https://esm.run/@observablehq/plot'

      cell("plot", ["counter"], (counter) => {
        const numbers = [
          170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
          176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
          166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
          163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
        ]
        return Plot.plot({
          marks: [
            Plot.lineY(numbers, { x: (d, i) => i, y: d => d }),
            Plot.ruleX([counter % 40])
          ]
        })
      });
    </script>

    <h2>Inputs</h2>

    <p>We'll create a new cell type <code>viewof</code> that works specifically with <a
        href="https://github.com/observablehq/inputs">Observable
        Inputs</a>.

      It declares 2 reactive cells: <code>NAME</code> and <code>viewof NAME</code> - one for the value, and one for the
      DOM element itself.

      <script type="module" class="echo">
        function viewof(name, inputsOrDefinition, maybeDefinition) {
          if (maybeDefinition) {
            const inputs = inputsOrDefinition
            const definition = maybeDefinition
            module.variable(observer(name)).define("viewof " + name, inputs, definition)
            module.variable().define(name, ["viewof " + name], (inpt) => library.Generators.input(inpt))
          } else {
            const definition = inputsOrDefinition
            module.variable(observer(name)).define("viewof " + name, definition)
            module.variable().define(name, ["viewof " + name], (inpt) => library.Generators.input(inpt))
          }
        }
        window.viewof = viewof
      </script>

      Wiggle the range input and see another dependent cell update.

      <script type="module" class="echo" id="range">
        import * as Inputs from 'https://esm.run/@observablehq/inputs'

        viewof("range", () => {
          return Inputs.range([0, 100], { step: 1 })
        });
      </script>

      <script type="module" class="echo" id="rangePlot">
        import * as Plot from 'https://esm.run/@observablehq/plot'

        cell("rangePlot", ["range"], (range) => {
          return Plot.tickX([range]).plot({ x: { domain: [0, 100] } })
        });
      </script>


      <h2>Cell status</h2>

      Observable's <code>Inspector</code> applies a <code>observablehq--running</code> and a
      <code>observablehq--error</code> class to the cell's <code>div</code> result element. 
      We'll create some appropriate styles:

      <style class="echo">
        @keyframes pulsate {
          content
          0%   {background-color: white;}
          50%  {background-color: grey;}
          100% {background-color: white;}
        }

        .observablehq--running:after {
          content: '·';
          animation: pulsate 2s infinite;
        }

        .observablehq--error {
          color: #d00;
        }
      </style>

      <script type="module" class="echo" id="running">
        cell("running", () => {
          // this cell will run forever
          return new Promise(() => {})
        });
      </script>

      <script type="module" class="echo" id="error">
        cell("error", () => {
          throw new Error("This cell has thrown an error")
        });
      </script>

  </main>
</body>
</html>