<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="main.css" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="description" content="Yes (by standing on the shoulders of Observable)">
  <meta name="author" content="Max Bo">

  <!-- OG meta tags -->
  <meta property="og:title" content="Can we build a reactive article in a single HTML file?">
  <meta property="og:description" content="Yes (by standing on the shoulders of Observable)">
  <meta property="og:image" content="https://maxbo.me/img/document.png">
  <meta property="og:url" content="https://maxbo.me/a-html-file-is-all-you-need.html">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="Max Bo">
  <meta property="og:locale" content="en_GB">
  <meta property="article:published_time" content="2024-05-06T00:00:00Z">
  <meta property="article:modified_time" content="2024-05-08T00:00:00Z">
  <meta property="article:author" content="Max Bo">
  <meta property="article:section" content="Technology">
  <meta property="article:tag" content="HTML">
  <meta property="article:tag" content="Observable">

  <!-- Twitter meta tags -->
  <meta name="twitter:site" content="@_max_bo_">
  <meta name="twitter:creator" content="@_max_bo_">
  <meta name="twitter:title" content="Can we build a reactive article in a single HTML file?">
  <meta name="twitter:description" content="Yes (by standing on the shoulders of Observable)">
  <meta name="twitter:image" content="https://maxbo.me/img/document.png">
  <meta name="twitter:url" content="https://maxbo.me/a-html-file-is-all-you-need.html">

  <title>Can we build a reactive article in a single HTML file?</title>
</head>

<body>
<main>
<header style="padding-bottom: 1rem">
  <nav>
    <h2>
      <marquee>
        <a href="/">‚Üê Max Bo</a>
      </marquee>
    </h2>
  </nav>
  Published <time datetime="2024-05-06">May 6, 2024</time>
  <br />
  Modified <time datetime="2024-05-06">May 8, 2024</time>
  <h1 style="margin-bottom: 1rem">Can we build a reactive article in a single HTML file?</h1>
  <b>Yes</b> <small><i>(by standing on the shoulders of <a href="https://observablehq.com/">Observable</a>)</i></small>.
</header>

Before I start, why am I doing this?
<br />
<br />
I don't think HTML is being used enough for scientific publishing.
<br />
People are commonly using either full-blown publishing platforms, like <a href="https://quarto.org/">Quarto</a>, <a href="https://typst.app/">Typst</a> and <a href="https://overleaf.com">Overleaf</a>, using interactive notebooks, like <a href="https://jupyter.org/">Jupyter</a>, <a href="https://plutojl.org/">Pluto.jl</a> and <a href="https://observablehq.com/">Observable</a>, or wiki platforms like <a href="https://obsidian.md/publish">Obsidian Publish</a>.
<br />
<br />
I think self-contained HTML files can provide a similar set of affordances, and prevent a lot of faffing around with CLI tooling, CI steps, or 3rd-party platforms.
<br />
<br />
<aside>
  <p>
    While I have not used <a href="https://htmx.org/">htmx</a>, I believe I am obligated to mention it.
    I think it's a great advance for HTML hypermedia.
  </p>
</aside>
I'll try and demonstrate these affordances, literate programming style.

<div class="center-contents">
  <img src="img/document.png" alt="A computer displays an open book" style="max-width: 125px; margin: 1rem" />
</div>

<h2>Cells</h2>


First, we'll steal a trick from <a href="https://secretgeek.github.io/html_wysiwyg/html.html">This page is a truly naked, brutalist html quine</a>, and create a CSS class called <code>echo</code> that will display/reflect <code>style</code> and <code>script</code> elements inline.

<style class="echo">
.echo {
  display: block;
  white-space: pre;
  font-family: monospace;
  background-color: #EEE;
  border: 3px inset;
  margin-bottom: 1rem;
  margin-top: 0.2rem;
  padding: 0.5rem 1rem 1rem 1rem;
  overflow: auto;
}
script.echo::before {
  content: "<script type=\"" attr(type) "\" class=\"" attr(class) "\" id=\"" attr(id) "\">";
}
script.echo::after { 
  content: "<\/script>"; 
}
style.echo::before { 
  content: "<style class=\"" attr(class)"\">"; 
}
style.echo::after { 
  content: "<\/style>"; 
}
*.echo::before, *.echo::after {
  color: darkgreen; 
}
</style>

Now we'll import the <a href="https://github.com/observablehq/stdlib">Observable standard library</a> and the <a href="https://github.com/observablehq/runtime">Observable runtime</a>, and bind them to <code>window</code>.
We'll define helper methods <code>cell</code> and <code>observer</code> that wrap some of the runtime API.

<script type="module" class="echo">
import * as stdlib from 'https://esm.run/@observablehq/stdlib'
import { Runtime, Inspector } from "https://esm.run/@observablehq/runtime";

const library = new stdlib.Library();
const runtime = new Runtime();
const module = runtime.module();

function cell(name, inputsOrDefinition, maybeDefinition) {
  if (maybeDefinition) {
    const inputs = inputsOrDefinition;
    const definition = maybeDefinition;
    module.variable(observer(name)).define(name, inputs, definition);
  } else {
    const definition = inputsOrDefinition;
    module.variable(observer(name)).define(name, definition);
  }
}

function observer(cellName) {
  const div = document.createElement("div");
  const cellElement = document.getElementById(cellName)
  cellElement.parentNode.insertBefore(div, cellElement);
  return new Inspector(div);
}

window.library = library;
window.module = module;
window.cell = cell;
window.observer = observer;
</script>

Now we'll declare a cell called <code>counter</code> that emits a number every second.
<b>The <code>script</code>'s <code>id</code> attribute is the same as the <code>name</code> parameter passed to <code>cell</code></b>.

<script type="module" class="echo" id="counter">
cell("counter", async function* () {
  let i = 0;
  while (true) {
    yield library.Promises.delay(1000, i++);
  }
});
</script>

Now that we've created a our <code>counter</code> cell, we can create other cells that depend on it.

<br />

We'll import <a href="https://github.com/observablehq/htl">Hypertext Literal</a> and use it to format the
<code>counter</code> value.

<script type="module" class="echo" id="fizzbuzz">
import * as htl from 'https://esm.run/htl';
window.htl = htl;

cell("fizzbuzz", ["counter"], (counter) => {
  if (counter % 3 === 0 && counter % 5 === 0) {
    return htl.html`<b style="color: purple">FizzBuzz</b>`;
  } else if (counter % 3 === 0) {
    return htl.html`<b style="color: red">Fizz</b>`;
  } else if (counter % 5 === 0) {
    return htl.html`<b style="color: blue">Buzz</b>`;
  } else {
    return htl.html`<b>${counter}</b>`;
  }
});
</script>

We'll import <a href="https://observablehq.com/plot/what-is-plot">Observable Plot</a> and use the <code>counter</code> value in the plot.

<script type="module" class="echo" id="plot">
import * as Plot from 'https://esm.run/@observablehq/plot'
window.Plot = Plot

cell("plot", ["counter"], (counter) => {
  const numbers = JSON.parse(document.getElementById("numbers").text);

  return Plot.plot({
    marks: [
      Plot.lineY(numbers, { x: (d, i) => i, y: d => d }),
      Plot.ruleX([counter % 40])
    ]
  });
});
</script>

<i>We should always store data in their own <code>script</code> elements, so that they can be easily referenced by other cells.</i>

<br />

<script class="echo" id="numbers" type="application/json">
[
  170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
  176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
  166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
  163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
]
</script>

<div class="center-contents">
  <img src="img/up.png" alt="A computer displays a graph in the upward direction" style="max-width: 125px" />
</div>

<h2>Inputs</h2>

We'll create a new cell type <code>viewof</code> that works specifically with <a href="https://github.com/observablehq/inputs">Observable Inputs</a>.

It declares 2 reactive cells: <code>NAME</code> and <code>viewof NAME</code> - one for the value, and one for the DOM element itself.

<script type="module" class="echo">
import * as Inputs from 'https://esm.run/@observablehq/inputs'
window.Inputs = Inputs

function viewof(name, inputsOrDefinition, maybeDefinition) {
  if (maybeDefinition) {
    const inputs = inputsOrDefinition;
    const definition = maybeDefinition;
    module.variable(observer(name)).define(`viewof ${name}`, inputs, definition);
    module.variable().define(name, [`viewof ${name}`], (inpt) => library.Generators.input(inpt));
  } else {
    const definition = inputsOrDefinition
    module.variable(observer(name)).define(`viewof ${name}`, definition);
    module.variable().define(name, [`viewof ${name}`], (inpt) => library.Generators.input(inpt));
  }
}
window.viewof = viewof;
</script>

Wiggle the range input and see another dependent cell update.


<script type="module" class="echo" id="range">
viewof("range", () => {
  return Inputs.range([0, 100], { step: 1 });
});
</script>

<script type="module" class="echo" id="rangePlot">
cell("rangePlot", ["range"], (range) => {
  return Plot.tickX([range]).plot({ x: { domain: [0, 100] } });
});
</script>

<h2>Mutability</h2>

Purely functional dataflow is great, but sometimes you just need to mutate state.
We'll create a new cell type <code>mutable</code>. It registers a <code>Mutable</code> - an object that yields new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a> values when the value is mutated - in the runtime.

<script type="module" class="echo" id="mutable">
/** Hijacked from https://github.com/observablehq/stdlib/blob/main/src/mutable.js */
function Mutable(value) {
  let change;
  return Object.defineProperty(
    library.Generators.observe((_) => {
      change = _;
      if (value !== undefined) change(value);
    }),
    "value",
    {
      get: () => value,
      set: (x) => void change((value = x))
    }
  );
}

function mutable(name, value) {
  const m = Mutable(value);
  module.variable(observer(name)).define(name, m);
  return m;
}
window.mutable = mutable;
</script>

<script type="module" class="echo" id="ref">
window.ref = mutable("ref", 3)
</script>

<script type="module" class="echo" id="increment">
viewof("increment", () => {
  const increment = () => ++ref.value;
  const reset = () => ref.value = 0;

  return Inputs.button([["Increment", increment], ["Reset", reset]]);
});
</script>

<script type="module" class="echo" id="sword">
cell("sword", ["ref"], (ref) => {
  return htl.html`‚Üú(‚ï∞ ‚Ä¢œâ‚Ä¢)‚ïØ |${'‚ïê'.repeat(ref)}‚ïêÔ∫§`
});
</script>

<h2>TeX, Markdown, Graphviz</h2>

What's the point otherwise?

<script type="module" class="echo" id="tex">
cell("tex", async () => {
  const tex = await library.tex()
  return tex`
\def\f#1#2{#1f(#2)}
\f\relax{x} = \int_{-\infty}^\infty
    \f\hat\xi\,e^{2 \pi i \xi x}
    \,d\xi`
});
</script>

<script type="module" class="echo" id="markdown">
const elements = JSON.parse(document.getElementById("elements").text);

cell("markdown", async () => {
  const md = await library.md();
  return md`
| Name      | Symbol      | Atomic number |
|-----------|-------------|---------------|${elements.map(e => `
| ${e.name} | ${e.symbol} | ${e.number}   |`)}
`;
});
</script>

<script class="echo" id="elements" type="application/json">
[
  { "symbol": "Co", "name": "Cobalt", "number": 27 },
  { "symbol": "Cu", "name": "Copper", "number": 29 },
  { "symbol": "Sn", "name": "Tin", "number": 50 },
  { "symbol": "Pb", "name": "Lead", "number": 82 }
]
</script>

<script type="module" class="echo" id="dot">
cell("dot", async () => {
  const dot = await library.dot();
  return dot`
digraph G {
  rankdir = LR
  a -> b -> c
}`;
});
</script>

<div class="center-contents">
  <img src="img/data.png" alt="A computer with an open CD tray is surrounded by data" style="max-width: 125px; margin: 1rem" />
</div>


<h2>SQLite</h2>

I've hosted the <a href="https://github.com/lerocha/chinook-database">Chinook sample database</a> on my website at <a href="https://maxbo.me/chinook.db">https://maxbo.me/chinook.db</a>.
Now we'll use a <a href="https://observablehq.com/framework/lib/sqlite">WASM-backed SQLite client</a> to query it.

<script type="module" class="echo" id="sqlite">
cell("sqlite", async () => {
  const url = "https://maxbo.me/chinook.db";
  const db = await library.SQLiteDatabaseClient().open(url);
  const tracks = await db.query("SELECT * FROM tracks");

  return Plot.plot({
    title: htl.html`<h3>Track length distribution</h3>`,
    marks: [
      Plot.rectY(
        tracks,
        Plot.binX({ y: "count" }, { x: "Milliseconds", tip: true })
      ),
      Plot.ruleY([0])
    ]
  });
});
</script>

<h2>Python</h2>

The <a href="http://pyodide.org/">Pyodide</a> CPython WASM distribution includes <a href="https://numpy.org/">NumPy</a>, <a href="https://pandas.pydata.org/">Pandas</a>, <a href="https://matplotlib.org/">Matplotlib</a>, <a href="https://scikit-learn.org/">scikit-learn</a>, and <a href="https://scipy.org/">Scipy</a>.
We'll rebuild the plot seen above, but using Matplotlib and Python's <code>sqlite3</code> module instead.

<script type="module" class="echo" id="python">
import { loadPyodide } from 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.mjs'
cell("python", async () => {
  const pyodide = await loadPyodide();

  const response = await fetch('https://maxbo.me/chinook.db');
  pyodide.FS.writeFile('/chinook.db', new Uint8Array(await response.arrayBuffer()));

  await pyodide.loadPackage(['sqlite3', 'matplotlib', 'pandas']);
  const code = `
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

with sqlite3.connect("/chinook.db") as conn:
  tracks_df = pd.read_sql_query("SELECT * FROM tracks", conn)

plt.title('Track length distribution')
plt.hist(tracks_df['Milliseconds'], bins='auto')
plt.xlabel('Milliseconds')
plt.ylabel('Frequency')

import io, base64
buf = io.BytesIO()
plt.savefig(buf, format='png')
buf.seek(0)
'data:image/png;base64,' + base64.b64encode(buf.read()).decode()
`;

  const imageDataUrl = await pyodide.runPythonAsync(code);
  const imageElement = document.createElement('img');
  imageElement.src = imageDataUrl;

  return imageElement;
});
</script>


<h2>R</h2>

You know the drill. It's R, using <a href="https://docs.r-wasm.org/webr/latest/">WebR</a>. 
I didn't figure out how to get <a href="https://ggplot2.tidyverse.org/">ggplot2</a> <a href="https://docs.r-wasm.org/webr/latest/plotting.html">rendering</a>, but I assume it's possible.

<br />

<script type="module" class="echo" id="r">
import { WebR } from 'https://webr.r-wasm.org/latest/webr.mjs';

cell("r", async () => {
  const webR = new WebR();
  await webR.init();

  const response = await fetch('https://maxbo.me/chinook.db');
  webR.FS.writeFile('/chinook.db', new Uint8Array(await response.arrayBuffer()));

  await webR.installPackages(['RSQLite'])
  const shelter = await new webR.Shelter();
  
  const code = `
library(RSQLite)
conn <- dbConnect(SQLite(), "/chinook.db")
track_data <- dbGetQuery(conn, "SELECT Milliseconds FROM tracks")
dbDisconnect(conn)

hist(track_data$Milliseconds, 
  breaks = 50,
  main = "Track length distribution",
  xlab = "Duration (Milliseconds)")
  `
  const capture = await shelter.captureR(code);

  const output = document.createElement('div');

  capture.images.forEach((img) => {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, img.width, img.height);
    output.appendChild(canvas);
  });

  shelter.purge();

  return output
});
</script>

<h2>Cell status</h2>

Observable's <code>Inspector</code> can apply an <code>observablehq--running</code> or
<code>observablehq--error</code> class to the cell's <code>div</code> result element.
We'll style them appropriately:

<style class="echo">
@keyframes blink {
  67% {
    opacity: 0
  }
}

.observablehq {
  margin-top: 1rem;
}

.observablehq--running::before {
  content: 'LOADING';
  animation: blink 1s step-end infinite;
}

.observablehq--error {
  color: #d00;
}
</style>

<script type="module" class="echo" id="running">
cell("running", () => {
  // this cell will run forever
  return new Promise(() => { });
});
</script>

<script type="module" class="echo" id="error">
cell("error", () => {
  throw new Error("This cell has thrown an error");
});
</script>

<h2>What's next?</h2>

I will try and cram all of this into a library with some proper documentation. Stay tuned.


<div class="center-contents">
  <img src="img/typing.gif" alt="A computer terminal receives text" style="margin: 1rem" />
</div>

<!-- To the reader

I was going to try and get this section working but this article didn't do
well on HN so I gave up. Rather not scream into the void.

<h2>contenteditable</h2>

<script>
function rerun(event) {
  const existingScript = event.target;
  const scriptContent = existingScript.textContent;
  const newScript = document.createElement('script');
  newScript.textContent = scriptContent;
  for (let i = 0; i < existingScript.attributes.length; i++) {
    newScript.setAttribute(existingScript.attributes[i].name, existingScript.attributes[i].value || '');
  }
  existingScript.parentNode.insertBefore(newScript, existingScript);
  existingScript.parentNode.removeChild(existingScript);
}
</script> 
-->

</main>
</body>

</html>
