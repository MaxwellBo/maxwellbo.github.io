<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="a-html-file-is-all-you-need.css" rel="stylesheet">
  <link rel="icon" type="image/png" href="img/cursor-dino.png">
  <meta charset="UTF-8">
  <meta name="description" content="Can we build a reactive notebook in a single HTML file? Yes (by standing on the shoulders of Observable)">
  <meta property="og:description" content="Can we build a reactive notebook in a single HTML file? Yes (by standing on the shoulders of Observable)">
  <meta name="twitter:description" content="Can we build a reactive notebook in a single HTML file? Yes (by standing on the shoulders of Observable)">
  <meta name="author" content="Max Bo">

  <!-- OG meta tags -->
  <meta property="og:title" content="Reactive HTML notebooks">

  <meta property="og:image" content="https://maxbo.me/img/document.png">
  <meta property="og:url" content="https://maxbo.me/a-html-file-is-all-you-need">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="Max Bo">
  <meta property="og:locale" content="en_GB">
  <meta property="article:published_time" content="2024-05-06T00:00:00Z">
  <meta property="article:modified_time" content="2024-08-21T00:00:00Z">
  <meta property="article:author" content="Max Bo">
  <meta property="article:section" content="Technology">
  <meta property="article:tag" content="HTML">
  <meta property="article:tag" content="Observable">

  <!-- Twitter meta tags -->
  <meta name="twitter:site" content="maxbo.me">
  <meta name="twitter:creator" content="@_max_bo_">
  <meta name="twitter:title" content="Reactive HTML notebooks">

  <!-- <meta name="twitter:image" content="https://maxbo.me/img/document.png"> -->
  <meta name="twitter:url" content="https://maxbo.me/a-html-file-is-all-you-need">

  <title>Reactive HTML notebooks ⋅ Max Bo</title>
</head>

<body>
<main>
<div class="slide">
<header style="padding-bottom: 1rem">
  <nav>
    <h2>
      <marquee>
        <a href="index.html">← Max Bo</a>
      </marquee>
    </h2>
  </nav>
  Published <time datetime="2024-05-06">May 6, 2024</time>
  <br />
  Modified <time datetime="2024-05-06">September 9, 2024</time>
  <h1 style="margin-bottom: 1rem">Reactive HTML notebooks</h1>
</header>
</div>

<div class="slide">

Before I start, why am I doing this?
<br />
<br />
<b>I don't think HTML is being used enough as a platform for scientific publishing.</b>
<br />
<br />
Instead, people will:
<ol>
  <li>First use an interactive notebook like <a href="https://jupyter.org/">Jupyter</a>, <a href="https://rmarkdown.rstudio.com/lesson-10.html">RStudio</a>, <a href="https://plutojl.org/">Pluto.jl</a> or <a href="https://observablehq.com/">Observable</a> to do data exploration, analysis and visualisation,</li>
  <li>Then move to publishing platforms like <a href="https://typst.app/">Typst</a>, <a href="https://overleaf.com">Overleaf</a>, pure <a href="https://www.latex-project.org/">LaTeX</a>, or a <a href="https://en.wikipedia.org/wiki/WYSIWYG">WYSIWYG</a> editor to typeset their work.</li>
</ol>
<br />
I think self-contained HTML files can be used for both of these stages, and prevent a lot of faffing around with CLI tooling, CI steps, or 3rd-party platforms.
<br />
<br />
HTML's typesetting capabilities are well documented, but its capabilities as a platform for data exploration, analysis and visualisation are not.
<br />
<aside>
  <p>
    This article takes heavy inspiration from Anton Zhiyanov's <a href="https://antonz.org/in-browser-code-playgrounds/">In-browser code playgrounds</a>, Cristóbal Sciutto</a>'s <a href="https://cristobal.space/note">Self-modifying HTML notes</a>, <a href="https://quarto.org/">Quarto</a>, and <a href="https://observablehq.com/framework/">Observable Framework</a>
  </p>
</aside>
<br />
I'll try and demonstrate these capabilities, literate programming style.
<br />

<div class="center-contents">
  <img src="img/document.png" alt="A computer displays an open book" style="max-width: 125px; margin: 1rem" />
</div>

</div>

<div class="slide">
<h2>Cells</h2>


First, we'll steal a trick from <a href="https://secretgeek.github.io/html_wysiwyg/html.html">This page is a truly naked, brutalist html quine</a>, and create a CSS class called <code>echo</code> that will display/reflect <code>style</code> and <code>script</code> elements inline.
<br />
<br />
Add in a <a href="https://blog.glyphdrawing.club/font-with-built-in-syntax-highlighting/">font with built-in syntax highlighting</a> and a <code>contenteditable</code> attribute and we have a basic code editor!
<br />
<br />
I stress that <b>this <code>style</code> element is styling itself.</b> 

<style class="echo" contenteditable="true">
@font-face {
  font-family: 'Monaspace';
  src: 
    url('fonts/MonaspaceKrypton-SyntaxHighlighter-Regular.woff2') 
    format('woff2')
  ;
}

[contenteditable] {
  border: 3px inset;
}

.echo {
  display: block;
  margin-bottom: 1rem;
  margin-top: 0.2rem;
  padding: 0.5rem 1rem 1rem 1rem;
  overflow: auto;
  /* syntax highlighting */
  font-family: "Monaspace", monospace;
  white-space: pre;
  font-feature-settings: "colr", "calt";
  font-size: 0.9rem;
  color: ivory;
  background-color: rgb(49, 49, 49); /* change me! */
}

script.echo::before {
  content: "<script type=\"" attr(type) "\" class=\"" attr(class) "\" id=\"" attr(id) "\" contenteditable=\"" attr(contenteditable) "\">";
}
script.echo::after { 
  content: "<\/script>"; 
}

style.echo::before { 
  content: "<style class=\"" attr(class) "\" contenteditable=\"" attr(contenteditable) "\">";
}
style.echo::after { 
  content: "<\/style>"; 
}
</style>
</div>

<div class="slide">
Now we'll import the <a href="https://github.com/observablehq/stdlib">Observable standard library</a> and the <a href="https://github.com/observablehq/runtime">Observable runtime</a>, and bind them to <code>window</code>.
We'll define helper methods <code>cell</code> and <code>observer</code> that wrap some of the runtime API.

<script type="module" class="echo">
import * as stdlib from 'https://esm.run/@observablehq/stdlib'
import { Runtime, Inspector } from "https://esm.run/@observablehq/runtime";

const library = new stdlib.Library();
const runtime = new Runtime();
const module = runtime.module();

function cell(name, inputsOrDefinition, maybeDefinition, observe = true) {
  // if the variable already is in scope, get it, otherwise create a fresh one
  const variable = module._scope.get(name) || module.variable(observe ? observer(name) : undefined);

  if (maybeDefinition) {
    const inputs = inputsOrDefinition;
    const definition = maybeDefinition;
    variable.define(name, inputs, definition);
  } else {
    const definition = inputsOrDefinition;
    variable.define(name, definition);
  }
}

// use the Observable inspector to display the cell's output above the script block
function observer(name) {
  const div = document.createElement("div");
  // can't use document.currentScript as it's null in module scripts
  const currentScript = document.getElementById(name);
  currentScript.parentNode.insertBefore(div, currentScript);
  return new Inspector(div);
}

window.library = library;
window.module = module;
window.cell = cell;
window.observer = observer;
</script>
</div>

<div class="slide">

Now we'll declare a cell called <code>counter</code> that emits a number every second.
<b>The <code>script</code>'s <code>id</code> attribute is the same as the <code>name</code> parameter passed to <code>cell</code></b>.

<script type="module" class="echo" id="counter" contenteditable="true">
cell("counter", async function* () {
  let i = 0;
  while (true) {
    await library.Promises.delay(1000);
    yield i++;
  }
});
</script>

</div>
<div class="slide">

<h3>contenteditable</h3>

We can get <code>contenteditable</code> working by ensuring that whenever we blur a <code>script</code> element, we force its re-evaluation by building a clone of it.
<br />
<br />
<i>Try deleting a <code>0</code> from the delay duration above, and then defocus the <code>script</code>.</i>

<script type="module" class="echo">
function reevaluate(event) {
  const old = event.target;
  const neww = document.createElement('script');
  neww.textContent = old.textContent;
  
  for (let i = 0; i < old.attributes.length; i++) {
    neww.setAttribute(old.attributes[i].name, old.attributes[i].value || '');
  }
  // register the blur listener again (given we've made a new script element)
  neww.addEventListener('blur', reevaluate);
  
  old.parentNode.insertBefore(neww, old);
  old.parentNode.removeChild(old);
}

// we want to redeclare scripts onblur
document.querySelectorAll('script.echo').forEach((script) => {
  script.addEventListener('blur', reevaluate);
});
</script>

</div>
<div class="slide">

Now that we've created a our <code>counter</code> cell, we can create other cells that depend on it.

<br />

We'll import <a href="https://observablehq.com/@observablehq/htl">Hypertext Literal</a> and use it to format the
<code>counter</code> value. <code>htl</code> implements a full-blown HTML5 parser that performs automatic escaping and 
interpolation of non-serializable values, such as event listeners, style objects, and other DOM nodes.

<script type="module" class="echo" id="fizzbuzz" contenteditable="true">
import * as htl from 'https://esm.run/htl';
window.htl = htl;

cell("fizzbuzz", ["counter"], (counter) => {
  if (counter % 3 === 0 && counter % 5 === 0) {
    return htl.html`<b style="color: purple">FizzBuzz</b>`;
  } else if (counter % 3 === 0) {
    return htl.html`<b style="color: red">Fizz</b>`;
  } else if (counter % 5 === 0) {
    return htl.html`<b style="color: blue">Buzz</b>`;
  } else {
    return htl.html`<b>${counter}</b>`;
  }
});
</script>

</div>


<div class="slide">
We can still observe the output of a cell without needing to show its definition. Just don't add the <code>echo</code> class. 
This makes them useful as a computational primitive.

<script type="module" id="hidden">
import * as htl from 'https://esm.run/htl';
window.htl = htl;

cell("hidden", ["counter"], (counter) => {
  return htl.html`<p>${counter}</p>`;
});
</script>
<i>(There's a hidden cell above ^)</i>

</div>

<br />
<br />
<br />

<div class="slide">

We can use cell values in more complex outputs. We'll import <a href="https://observablehq.com/plot/what-is-plot">Observable Plot</a> and use the <code>counter</code> value in a plot.

<script type="module" class="echo" id="plot" contenteditable="true">
import * as Plot from 'https://esm.run/@observablehq/plot'
window.Plot = Plot

cell("plot", ["counter", "numbers"], (counter, numbers) => {
  return Plot.plot({
    marks: [
      Plot.lineY(numbers, { x: (d, i) => i, y: d => d }),
      Plot.ruleX([counter % 40])
    ]
  });
});
</script>

</div>
<div class="slide">

<i>We should always store data in their own <code>script</code> elements, so that they can be easily referenced by other cells. Note that cells can be declared in any order in the page.</i>

<br />

<script type="module" class="echo" id="numbers" contenteditable="true">
cell("numbers", () => {
  return [
    170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
    176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
    166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
    163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
  ];
});
</script>
</div>

<div class="center-contents">
  <img src="img/up.png" alt="A computer displays a graph in the upward direction" style="max-width: 125px" />
</div>

<div class="slide">

<h2>TeX, Markdown, Graphviz</h2>

We can return any type of DOM element from a cell. 
<br />
In this case, the <code>tex</code>, <code>md</code>, and <code>dot</code> cells return <code>span</code>, <code>table</code> and <code>svg</code> elements respectively.

<script type="module" class="echo" id="tex" contenteditable="true">
cell("tex", async () => {
  const tex = await library.tex()
  return tex`
\def\f#1#2{#1f(#2)}
\f\relax{x} = \int_{-\infty}^\infty
    \f\hat\xi\,e^{2 \pi i \xi x}
    \,d\xi`
});
</script>

</div>
<div class="slide">

<script type="module" class="echo" id="markdown" contenteditable="true">
cell("markdown", ["elements"], async (elements) => {
  const md = await library.md();
  return md`
| Name      | Symbol      | Atomic number |
|-----------|-------------|---------------|${elements.map(e => `
| ${e.name} | ${e.symbol} | ${e.number}   |`)}
`;
});
</script>

<script type="module" class="echo" id="elements" contenteditable="true">
cell("elements", () => {
  return [
    { "symbol": "Co", "name": "Cobalt", "number": 27 },
    { "symbol": "Cu", "name": "Copper", "number": 29 },
    { "symbol": "Sn", "name": "Tin", "number": 50 },
    { "symbol": "Pb", "name": "Lead", "number": 82 }
  ];
});
</script>

</div>
<div class="slide">

<script type="module" class="echo" id="dot" contenteditable="true">
cell("dot", async () => {
  const dot = await library.dot();
  return dot`
digraph G {
  rankdir = LR
  a -> b -> c
}`;
});
</script>

</div>

<div class="center-contents">
  <img src="img/data.png" alt="A computer with an open CD tray is surrounded by data" style="max-width: 125px; margin: 1rem" />
</div>

<div class="slide">

<h2>Cell status</h2>

We can also return a <code>Promise</code>, or throw an <code>Error</code>, from a cell.

Observable's <code>Inspector</code> will apply an <code>observablehq--running</code> or
<code>observablehq--error</code> class to the cell's outer <code>div</code> element respectively.
We'll style them appropriately:

<style class="echo">
@keyframes blink {
  67% {
    opacity: 0;
  }
}

.observablehq {
  margin-top: 1rem;
}

.observablehq--running::before {
  content: 'LOADING';
  animation: blink 1s step-end infinite;
}

.observablehq--error {
  color: #d00;
}
</style>

</div>
<div class="slide">

<script type="module" class="echo" id="running">
cell("running", () => {
  // this cell will run forever
  return new Promise(() => { });
});
</script>

<script type="module" class="echo" id="error">
cell("error", () => {
  throw new Error("This cell has thrown an error");
});
</script>

</div>
<div class="slide">
  
<h2>SQLite</h2>

I've hosted the <a href="https://github.com/lerocha/chinook-database">Chinook sample database</a> on my website at <a href="https://maxbo.me/chinook.db">https://maxbo.me/chinook.db</a>.
Now we'll use a <a href="https://observablehq.com/framework/lib/sqlite">WASM-backed SQLite client</a> to query it.
<br />
<br />
<i>Try adding <code>WHERE Milliseconds &lt; 1000000</code> to the SQL query!</i>

<script type="module" class="echo" id="sqlite" contenteditable="true">
cell("sqlite", async () => {
  const url = "https://maxbo.me/chinook.db";
  const db = await library.SQLiteDatabaseClient().open(url);
  const tracks = await db.query("SELECT * FROM tracks");

  return Plot.plot({
    title: htl.html`<h3>Track length distribution</h3>`,
    marks: [
      Plot.rectY(
        tracks,
        Plot.binX({ y: "count" }, { x: "Milliseconds", tip: true })
      ),
      Plot.ruleY([0])
    ]
  });
});
</script>
</div>
<div class="slide">
<h2>Python</h2>

The <a href="http://pyodide.org/">Pyodide</a> CPython WASM distribution includes <a href="https://numpy.org/">NumPy</a>, <a href="https://pandas.pydata.org/">Pandas</a>, <a href="https://matplotlib.org/">Matplotlib</a>, <a href="https://scikit-learn.org/">scikit-learn</a>, and <a href="https://scipy.org/">Scipy</a>.
We'll rebuild the plot seen above, but using Matplotlib and Python's <code>sqlite3</code> module instead.

<script type="module" class="echo" id="python" contenteditable="true">
import { loadPyodide } from 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.mjs'
cell("python", async () => {
  const pyodide = await loadPyodide();

  const response = await fetch('https://maxbo.me/chinook.db');
  pyodide.FS.writeFile('/chinook.db', new Uint8Array(await response.arrayBuffer()));

  await pyodide.loadPackage(['sqlite3', 'matplotlib', 'pandas']);
  const code = `
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

with sqlite3.connect("/chinook.db") as conn:
  tracks_df = pd.read_sql_query("SELECT * FROM tracks", conn)

plt.title('Track length distribution')
plt.hist(tracks_df['Milliseconds'], bins='auto')
plt.xlabel('Milliseconds')
plt.ylabel('Frequency')

import io, base64
buf = io.BytesIO()
plt.savefig(buf, format='png')
buf.seek(0)
'data:image/png;base64,' + base64.b64encode(buf.read()).decode()
`;

  const imageDataUrl = await pyodide.runPythonAsync(code);
  const imageElement = document.createElement('img');
  imageElement.src = imageDataUrl;

  return imageElement;
});
</script>

</div>
<div class="slide">
<h2>R</h2>

You know the drill. It's R, using <a href="https://docs.r-wasm.org/webr/latest/">WebR</a>. 
I didn't figure out how to get <a href="https://ggplot2.tidyverse.org/">ggplot2</a> <a href="https://docs.r-wasm.org/webr/latest/plotting.html">rendering</a> working, but I assume it's possible.

<i>I must disclose that this cell seems to be a bit flaky on iOS. I have not had a chance to investigate further, nor will I.</i>

<script type="module" class="echo" id="r" contenteditable="true">
import { WebR } from 'https://webr.r-wasm.org/latest/webr.mjs';

cell("r", async () => {
  const webR = new WebR();
  await webR.init();

  const response = await fetch('https://maxbo.me/chinook.db');
  webR.FS.writeFile('/chinook.db', new Uint8Array(await response.arrayBuffer()));

  await webR.installPackages(['RSQLite'])
  const shelter = await new webR.Shelter();
  
  const code = `
library(RSQLite)
conn <- dbConnect(SQLite(), "/chinook.db")
track_data <- dbGetQuery(conn, "SELECT Milliseconds FROM tracks")
dbDisconnect(conn)

hist(track_data$Milliseconds, 
  breaks = 50,
  main = "Track length distribution",
  xlab = "Duration (Milliseconds)")`;

  const output = document.createElement('div');

  const capture = await shelter.captureR(code);

  capture.images.forEach((img) => {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, img.width, img.height);
    output.appendChild(canvas);
  });

  shelter.purge();

  return output
});
</script>

</div>
<div class="slide">

<h2>Inputs</h2>

We'll create a new cell type <code>viewof</code> that works specifically with <a href="https://github.com/observablehq/inputs">Observable Inputs</a>.

It declares 2 reactive cells: <code>NAME</code> and <code>viewof NAME</code> - one for the value, and one for the DOM element itself.

<script type="module" class="echo">
import * as Inputs from 'https://esm.run/@observablehq/inputs'
window.Inputs = Inputs

function viewof(name, inputsOrDefinition, maybeDefinition) {
  cell(`viewof ${name}`, inputsOrDefinition, maybeDefinition);
  cell(name, [`viewof ${name}`], (inpt) => library.Generators.input(inpt), /*observe=*/false);
}
window.viewof = viewof;
</script>

</div>
<div class="slide">

To display the input above the cell, we set the cell <code>id</code> to <code>viewof NAME</code>.
<br />
<br />
<i>Wiggle the range input and see another dependent cell update.</i>

<div id="range"></div>
<script type="module" class="echo" id="viewof range" contenteditable="true">
viewof("range", () => {
  return Inputs.range([0, 100], { step: 1 });
});
</script>

<script type="module" class="echo" id="rangePlot" contenteditable="true">
cell("rangePlot", ["range"], (range) => {
  return Plot.tickX([range]).plot({ x: { domain: [0, 100] } });
});
</script>

<i>NB: The way Observable Inputs work is a bit arcane. This demo of <a href="https://observablehq.com/@observablehq/synchronized-inputs">Synchronized Inputs</a> may shed some light.</i>

</div>
<div class="slide">

<h2>Mutability</h2>

Purely functional dataflow is great, but sometimes you just need to mutate state.
We'll create a new helper function <code>mutable</code>. It registers a <code>Mutable</code> - an object that yields new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a> values when the value is mutated - in the runtime.

<script type="module" class="echo" id="mutable">
/** Hijacked from https://github.com/observablehq/stdlib/blob/main/src/mutable.js */
function Mutable(value) {
  let change;
  return Object.defineProperty(
    library.Generators.observe((_) => {
      change = _;
      if (value !== undefined) change(value);
    }),
    "value",
    {
      get: () => value,
      set: (x) => void change((value = x))
    }
  );
}

function mutable(name, value) {
  const m = Mutable(value);
  cell(name, m);
  return m;
}
window.mutable = mutable;
</script>

</div>
<div class="slide">

<i>Try editing the initial state of the <code>mutable</code>.</i>

<script type="module" class="echo" id="ref" contenteditable="true">
window.ref = mutable("ref", 3)
</script>

<i>Try editing the button labels.</i>

<script type="module" class="echo" id="viewof increment" contenteditable="true">
viewof("increment", () => {
  const increment = () => ++ref.value;
  const reset = () => ref.value = 0;

  return Inputs.button([["Increment", increment], ["Reset", reset]]);
});
</script>

<script type="module" class="echo" id="sword" contenteditable="true">
cell("sword", ["ref"], (ref) => {
  return htl.html`↜(╰ •ω•)╯ |${'═'.repeat(ref)}═ﺤ`
});
</script>

</div>


<!-- <h2>3D models</h2>

We can use Google's <a href="https://modelviewer.dev/"><code>&lt;model-viewer&gt;</code></a> <a href="https://www.webcomponents.org/introduction">Web Component</a> to display 3D models.

<script type="module" class="echo" id="model">
import 'https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js';

cell("model", async () => {
  return htl.html`
    <model-viewer 
      style="width: 100%; height: 400px"
      src="/models/NeilArmstrong.glb" 
      poster="/models/NeilArmstrong.webp" 
      alt="Neil Armstrong's Spacesuit from the Smithsonian Digitization Programs Office and National Air and Space Museum" 
      ar 
      auto-rotate
      shadow-intensity="1" 
      camera-controls 
      touch-action="pan-y">
  </model-viewer>
  `;
});
</script> -->

<!-- <div class="slide"> -->

<!-- <h2>Saving contenteditable changes</h2>

Taking a note out of <a href="https://cristobal.space/">Cristóbal Sciutto</a>'s <a href="https://cristobal.space/note">Self-modifying HTML notes</a>,
it's very easy to save a modified version of our document to disk. -->

<!-- <script type="module" class="echo" id="download">
function download (html) {
  // Write data into self-contained html file
  const data = new Blob([html], {type: 'text/plain'});

  // Download the file
  const url = window.URL.createObjectURL(data);
  const a = document.createElement("a");
  a.href = url;
  a.download = "a-html-file-is-all-you-need.html";
  a.click();
}

cell("download", () => {
  return Inputs.button([["Download", () => download(document.documentElement.outerHTML)]]);
});
</script> -->


<!-- </div> -->
<div class="slide">

<h2>What's next?</h2>

I will try and cram all of this into a library with some proper documentation.

<br />
I initially thought it should be called <code>incel</code> (short for <i>inline cell</i>), but I'll probably call it <code>celine</code> instead.

<br />

<style>
  #subscribe {
    padding: 1rem;
    margin: 1rem;
    border: 1px solid black;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #subscribe #email {
    width: 100%;
  }
</style>

<!-- https://www.val.town/v/mbo/celinewaitlist -->
<form id="subscribe" action="https://mbo-celinewaitlist.web.val.run" method="POST">
<label for="email">Get notified when I publish <code>celine</code>?</label>
<br />
<input type="email" id="email" name="email" required placeholder="maxwell.j.bo+celinewaitlist@gmail.com">
<br />
<button type="submit">Submit</button>
</form>

<div class="center-contents">
  <img src="img/typing.gif" alt="A computer terminal receives text" style="margin: 1rem" />
</div>

</div>
<div class="slide">

<h2>Slide infrastructure</h2>


I demo'd this article at <a href="https://www.youtube.com/@SydJSMeetup">SydJS</a>. This is the code I used to turn the article into a slideshow.

<ul>
  <li><kbd>Shift</kbd> + <kbd>N</kbd> - Start slideshow / next slide</li>
  <li><kbd>Shift</kbd> + <kbd>B</kbd> - Previous slide</li>
  <li><kbd>Shift</kbd> + <kbd>E</kbd> - End slideshow</li>
</ul>

<br />

<style class="echo">
  .slide {
    scroll-margin-top: 3rem;
  }
</style>

<script type="module" class="echo">
  let slide = -1;
  window.addEventListener('keydown', (event) => {
    if (event.shiftKey && event.key === 'N') {
      slide++;
      paint();
    }

    if (event.shiftKey && event.key === 'B') {
      slide--;
      paint();
    }

    if (event.shiftKey && event.key === 'E') {
      slide = -1;
      paint();
    }
  });

  function paint() {
    for (const s of document.querySelectorAll('.slide')) {
      s.style.border = 'none';
      s.style.opacity = 1;
    }

    if (slide >= 0) {
      document.querySelectorAll('.slide')[slide].style.border = '1px dotted grey';
      document.querySelectorAll('.slide')[slide].scrollIntoView({ behavior: 'smooth' });

      for (const s of document.querySelectorAll('.slide')) {
        if (s !== document.querySelectorAll('.slide')[slide]) {
          s.style.opacity = 0.4;
        }
      }
    }
  }
</script>

<footer>
    <a href="https://github.com/MaxwellBo/maxwellbo.github.io"><img class="badge" src="img/pages.png" /></a>
    <br />
    <small>© 2024</small>
</footer>

</main>
</body>

</html>
