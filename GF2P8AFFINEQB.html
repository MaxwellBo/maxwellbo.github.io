<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Off-label GF2P8AFFINEQB</title>

  <style>
    body {
      max-width: 800px;
      margin: 0 auto;
      /* font-family: 'Xanh Mono', serif; */
      padding: 20px;
      background-color: rgb(231, 239, 255);
    }

    table {
      border-collapse: collapse;
    }

    table, th, td {
      border: 1px solid #333;
    }

    td, th {
      padding: 8px;
      text-align: center;
    }

    th {
      background-color: #ddd;
    }
    
  </style>
</head>

<body>

  <main>

    <h1>GF2P8AFFINEQB</h1>

    <p>
      Often used as a way to take the piss out of CISC ISAs, <a href="https://www.felixcloutier.com/x86/gf2p8affineqb">GF2P8AFFINEQB</a>, the Galois Field Affine Transformation, and its sister instruction  <a href="https://www.felixcloutier.com/x86/gf2p8affineinvqb">GF2P8AFFINEINVQB</a>, part of the "Galois Field New Instructions" x86 extension, are actually quite useful.
    </p>

    <h2>What is a Galois field</h2>

    <p>
      Intel's 
    <a href="https://builders.intel.com/docs/networkbuilders/galois-field-new-instructions-gfni-technology-guide-1-1639042826.pdf">
      Galois Field New Instructions (GFNI) Technology Guide
    </a> gives a rather succinct definition:

    </p>
    <blockquote>
      A Galois Field is a field containing a finite number of elements. As with other fields, a Galois Field has well defined elements, and
operations for addition, subtraction, and so on, when applied to those elements generates a result in the same field. The GF(2) field
is simply a Galois Field with only two elements – 0 and 1. The addition of two values in GF(2) is equivalent to addition-modulo-2, or
an exclusive-OR. The multiplication of two values in GF(2) is equivalent to multiplication-modulo-2, or the logical AND operation.
Other operations are similarly defined.
    </blockquote>

    <div style="display: flex; gap: 20px; justify-content: center;">
      <table>
      <tr>
      <th>+</th>
      <th>0</th>
      <th>1</th>
      </tr>
      <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      </tr>
      <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      </tr>
      </table>

      <table>
      <tr>
      <th>×</th>
      <th>0</th>
      <th>1</th>
      </tr>
      <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      </tr>
      <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      </tr>
      </table>
    </div>

    <h2>How does GF2P8AFFINEQB work?</h2>

    <p>
      The GF2P8AFFINEQB instruction performs an affine transformation in GF(2^8). It multiplies an 8x8 bit matrix by an 8-bit input vector, then XORs the result with a constant. Click on the bits below to experiment:
    </p>

    <h3>Interactive example</h3>
    <div id="simulator-1" class="simulator-container"></div>

    <h3>5-bit sign extension</h3>
    <div id="simulator-2" class="simulator-container"></div>

    <style>
      .bit-cell {
        width: 35px;
        height: 35px;
        border: 2px solid #333;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-weight: bold;
        user-select: none;
        transition: background-color 0.1s;
      }
      
      .bit-cell.on {
        background-color: #4CAF50;
        color: white;
      }
      
      .bit-cell.off {
        background-color: #f0f0f0;
        color: #666;
      }
      
      .bit-cell.result {
        cursor: default;
        background-color: #2196F3;
        color: white;
      }

      .bit-cell.readonly {
        cursor: default;
      }
    </style>

    <script>
      class GF2P8Simulator {
        constructor(containerId, initialMatrix, initialInput) {
          this.containerId = containerId;
          this.matrix = initialMatrix;
          this.inputVector = initialInput;
          this.init();
        }

        init() {
          const container = document.getElementById(this.containerId);
          container.innerHTML = `
            <div style="display: flex; gap: 40px; align-items: flex-start; flex-wrap: wrap;">
              <div>
                <h4>Matrix (row-major)</h4>
                <div style="position: relative;">
                  <div style="position: absolute; top: -5px; left: -5px; font-size: 12px; color: #666;">MSB</div>
                  <div style="position: absolute; top: -5px; right: -5px; font-size: 12px; color: #666;">LSB</div>
                  <div class="matrix-grid" style="display: grid; grid-template-columns: repeat(8, 35px); gap: 2px;"></div>
                  <div style="position: absolute; bottom: -5px; left: -5px; font-size: 12px; color: #666;">LSB</div>
                  <div style="position: absolute; bottom: -5px; right: -5px; font-size: 12px; color: #666;">MSB</div>
                </div>
              </div>
              
              <div>
                <h4>Input vector</h4>
                <div style="position: relative;">
                  <div style="position: absolute; top: -5px; left: -5px; font-size: 12px; color: #666;">LSB</div>
                  <div class="input-vector" style="display: grid; grid-template-columns: 35px; gap: 2px;"></div>
                  <div style="position: absolute; bottom: -5px; left: -5px; font-size: 12px; color: #666;">MSB</div>
                </div>
              </div>
              
              <div>
                <h4>Result</h4>
                <div style="position: relative;">
                  <div style="position: absolute; top: -5px; left: -5px; font-size: 12px; color: #666;">LSB</div>
                  <div class="result-vector" style="display: grid; grid-template-columns: 35px; gap: 2px;"></div>
                  <div style="position: absolute; bottom: -5px; left: -5px; font-size: 12px; color: #666;">MSB</div>
                </div>
              </div>
            </div>

            <details style="margin-top: 20px;">
              <summary style="cursor: pointer; font-weight: bold;">C++</summary>
              <pre class="cpp-code" style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"></pre>
            </details>
            
            <details style="margin-top: 10px;">
              <summary style="cursor: pointer; font-weight: bold;">Rust</summary>
              <pre class="rust-code" style="background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"></pre>
            </details>
          `;
          
          this.updateAll();
        }

        createBitCell(value, onClick) {
          const cell = document.createElement('div');
          cell.className = `bit-cell ${value ? 'on' : 'off'}`;
          cell.textContent = value;
          if (onClick) {
            cell.addEventListener('click', onClick);
          }
          return cell;
        }

        updateMatrix() {
          const container = document.getElementById(this.containerId);
          const matrixGrid = container.querySelector('.matrix-grid');
          matrixGrid.innerHTML = '';
          
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              const cell = this.createBitCell(this.matrix[row][col], () => {
                this.matrix[row][col] = 1 - this.matrix[row][col];
                this.updateAll();
              });
              matrixGrid.appendChild(cell);
            }
          }
        }

        updateInputVector() {
          const container = document.getElementById(this.containerId);
          const inputGrid = container.querySelector('.input-vector');
          inputGrid.innerHTML = '';
          
          for (let i = 0; i < 8; i++) {
            const cell = this.createBitCell(this.inputVector[i], () => {
              this.inputVector[i] = 1 - this.inputVector[i];
              this.updateAll();
            });
            inputGrid.appendChild(cell);
          }
        }

        calculateResult() {
          const result = Array(8).fill(0);
          
          for (let row = 0; row < 8; row++) {
            let sum = 0;
            for (let col = 0; col < 8; col++) {
              sum ^= (this.matrix[row][col] & this.inputVector[col]);
            }
            result[row] = sum;
          }
          
          return result;
        }

        updateResult() {
          const container = document.getElementById(this.containerId);
          const result = this.calculateResult();
          const resultGrid = container.querySelector('.result-vector');
          resultGrid.innerHTML = '';
          
          for (let i = 0; i < 8; i++) {
            const cell = document.createElement('div');
            cell.className = 'bit-cell result';
            cell.textContent = result[i];
            resultGrid.appendChild(cell);
          }
        }

        vectorToUint8() {
          let value = 0;
          for (let i = 0; i < 8; i++) {
            value |= (this.inputVector[i] << i);
          }
          return value;
        }

        formatBinary8(num) {
          return '0b' + num.toString(2).padStart(8, '0');
        }

        updateCppCode() {
          const container = document.getElementById(this.containerId);
          const cppCode = container.querySelector('.cpp-code');
          
          let matrixLines = [];
          for (let row = 0; row < 8; row++) {
            let rowByte = 0;
            for (let col = 0; col < 8; col++) {
              rowByte |= (this.matrix[row][col] << col);
            }
            matrixLines.push(`    ((uint64_t)${this.formatBinary8(rowByte)} << (8 * ${row}))${row < 7 ? ' |' : '  '}`);
          }
          
          const inputByte = this.vectorToUint8();
          
          cppCode.textContent = `#include <immintrin.h>

const uint64_t matrix = (
${matrixLines.join('\n')}
);

const uint8_t input = ${this.formatBinary8(inputByte)};

// Perform the affine transformation
__m128i input_vec = _mm_set1_epi64x(input);
__m128i result = _mm_gf2p8affine_epi64_epi8(input_vec, _mm_set1_epi64x(matrix), 0);

// Extract result byte
uint8_t result_byte = _mm_extract_epi8(result, 0);`;
        }

        updateRustCode() {
          const container = document.getElementById(this.containerId);
          const rustCode = container.querySelector('.rust-code');
          
          let matrixLines = [];
          for (let row = 0; row < 8; row++) {
            let rowByte = 0;
            for (let col = 0; col < 8; col++) {
              rowByte |= (this.matrix[row][col] << col);
            }
            matrixLines.push(`    (${this.formatBinary8(rowByte)}u64 << (8 * ${row}))${row < 7 ? ' |' : ' '}`);
          }
          
          const inputByte = this.vectorToUint8();
          
          rustCode.textContent = `#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

#[target_feature(enable = "gfni,avx512f")]
unsafe fn gf2p8_affine_transform() -> u8 {
    let matrix: u64 = (
${matrixLines.join('\n')}
    );
    
    let input: u8 = ${this.formatBinary8(inputByte)};
    
    // Perform the affine transformation
    let input_vec = _mm_set1_epi64x(input as i64);
    let result = _mm_gf2p8affine_epi64_epi8(input_vec, _mm_set1_epi64x(matrix as i64), 0);
    
    // Extract result byte
    _mm_extract_epi8(result, 0) as u8
}`;
        }

        updateAll() {
          this.updateMatrix();
          this.updateInputVector();
          this.updateResult();
          this.updateCppCode();
          this.updateRustCode();
        }
      }

      // Initialize simulators
      // Simulator 1: Interactive with identity matrix
      const identityMatrix = Array(8).fill(0).map(() => Array(8).fill(0));
      for (let i = 0; i < 8; i++) {
        identityMatrix[i][i] = 1;
      }
      const sim1 = new GF2P8Simulator(
        'simulator-1',
        identityMatrix,
        [1, 1, 0, 0, 0, 0, 0, 0]
      );

      // Simulator 2: 5-bit sign extension
      const signExtendMatrix = [
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 1],
      ];
      const sim2 = new GF2P8Simulator(
        'simulator-2',
        signExtendMatrix,
        [0, 0, 0, 1, 1, 0, 0, 0] // 0b00011000
      );
    </script>


    <!-- INSERT SIMULATOR HERE -->

    <h2>How does GF2P8AFFINEINVQB work?</h2>

    <h2>Usage in C++</h2>

    <p>
      TODO
    </p>

    <h2>Usage in Rust</h2>

    <p>
      TODO
    </p>

    <h3>Applications</h3>

    <a href="https://gist.github.com/animetosho/d3ca95da2131b5813e16b5bb1b137ca0">
      listing of usecases
    </a>

    <a href="https://stackoverflow.com/questions/59124720/what-are-the-avx-512-galois-field-related-instructions-for">
      stackoverflow post
    </a>

    <h3>Reed-Solomon error correction</h3>

    <a href="https://github.com/klauspost/reedsolomon">klauspost/reedsolomon</a>

    <h3>Some shit I don't understand</h3>
    <a href="https://github.com/animetosho/ParPar/blob/master/fast-gf-multiplication.md#affine-transformation--bit-matrix-xor">
      i don't even fucking know man
    </a>

    <h3>PS3 Cell floating point emulation</h3>

    <p>
      <a href="https://www.youtube.com/watch?v=19ae5Mq2lJE">Here's the video that discusses it</a>
    </p>

    <p>
      <a href="https://github.com/RPCS3/rpcs3/pull/8712/files">PR</a>
    </p>

    <p>
      <a href="https://github.com/Whatcookie/rpcs3/blob/732fd479121fe09587fb43fce0cebb55f085d5e7/rpcs3/Emu/Cell/SPURecompiler.cpp#L7284-L7340">Updated version</a>
    </p>

    <h2>Go GC</h2>

    <p>
      <a href="https://go.dev/blog/greenteagc">https://go.dev/blog/greenteagc</a>
    </p>

    <h2>What can we apply it to?</h2>

    <p>
      &lt;search for an application and get a speedup&gt;
    </p>

  https://gist.github.com/animetosho/d3ca95da2131b5813e16b5bb1b137ca0 

  https://bitmath.blogspot.com/2023/04/not-transposing-16x16-bitmatrix.html

  </main>


</body>

</html>
