<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Papers I like</title>
  <script type="module" src="https://esm.sh/jsr/@celine/bibhtml@3.8.0"></script>
  <link rel="stylesheet" href="https://esm.sh/jsr/@celine/libertine@13.6.0/libertine.css" />
</head>
<body>
  <main>
    <div class="authors">
      <div class="author">
        <span class="author-name"><a href="https://maxbo.me">← Max Bo</a></span>
      </div>
    </div>
    <h1>
      Papers I like
    </h1>

    Now hosted on <a href="https://www.are.na/max-bo/papers-i-like-p2md50jw0de">are.na</a>

<!--     <div style="display: none"> -->
<!--       <bh-cite><a href="#dusa">?</a></bh-cite> -->
<!--       <bh-cite><a href="#build-systems-a-la-carte">?</a></bh-cite> -->
<!--       <bh-cite><a href="#document-calculus">?</a></bh-cite> -->
<!--       <bh-cite><a href="#hazel">?</a></bh-cite> -->
<!--       <bh-cite><a href="#simplest-sort">?</a></bh-cite> -->
<!--       <bh-cite><a href="#mcclellan2012">?</a></bh-cite> -->
<!--       <bh-cite><a href="#graf2022">?</a></bh-cite> -->
<!--       <bh-cite><a href="#wydrowski2023loadbalanceintroducingprequal">?</a></bh-cite> -->
<!--       <bh-cite><a href="#park2024iclrincontextlearningrepresentations">?</a></bh-cite> -->
<!--       <bh-cite><a href="#libkind2024patternrunsmatterfree">?</a></bh-cite> -->
<!--       <bh-cite><a href="#fp2">?</a></bh-cite> -->
<!--       <bh-cite><a href="#verse">?</a></bh-cite> -->
<!--       <bh-cite><a href="#dunning2021">?</a></bh-cite> -->
<!--       <bh-cite><a href="#Masson_2019">?</a></bh-cite> -->
<!--       <bh-cite><a href="#hyperloglog">?</a></bh-cite> -->
<!--       <bh-cite><a href="#litt2022">?</a></bh-cite> -->
<!--       <bh-cite><a href="#cividis">?</a></bh-cite> -->
<!--       <bh-cite><a href="#cnotlowlevel">?</a></bh-cite> -->
<!--       <bh-cite><a href="#li2022">?</a></bh-cite> -->
<!--       <bh-cite><a href="#asquith2023">?</a></bh-cite> -->
<!--       <bh-cite><a href="#wydrowski2023">?</a></bh-cite> -->
<!--       <bh-cite><a href="#neumann2015">?</a></bh-cite> -->
<!--       <bh-cite><a href="#neumann2024">?</a></bh-cite> -->
<!--       <bh-cite><a href="#boldyreva2009">?</a></bh-cite> -->
<!--       <bh-cite><a href="#hwang2015">?</a></bh-cite> -->
<!--       <bh-cite><a href="#boem2020">?</a></bh-cite> -->
<!--       <bh-cite><a href="#fong2025">?</a></bh-cite> -->
<!--     </div> -->
<!--  -->
<!--     <bh-reference id="dusa"> -->
<!--       @article{Martens_2025, -->
<!--         title={Finite-Choice Logic Programming}, -->
<!--         volume={9}, -->
<!--         ISSN={2475-1421}, -->
<!--         url={http://dx.doi.org/10.1145/3704849}, -->
<!--         DOI={10.1145/3704849}, -->
<!--         number={POPL}, -->
<!--         journal={Proceedings of the ACM on Programming Languages}, -->
<!--         publisher={Association for Computing Machinery (ACM)}, -->
<!--         author={Martens, Chris and Simmons, Robert J. and Arntzenius, Michael}, -->
<!--         year={2025}, -->
<!--         month=jan, pages={362–390} } -->
<!--       -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="build-systems-a-la-carte"> -->
<!--       @article{10.1145/3236774, -->
<!--         author = {Mokhov, Andrey and Mitchell, Neil and Peyton Jones, Simon}, -->
<!--         title = {Build systems \`{a} la carte}, -->
<!--         year = {2018}, -->
<!--         issue_date = {September 2018}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         volume = {2}, -->
<!--         number = {ICFP}, -->
<!--         url = {https://doi.org/10.1145/3236774}, -->
<!--         doi = {10.1145/3236774}, -->
<!--         abstract = {Build systems are awesome, terrifying -- and unloved. They are used by every developer around the world, but are rarely the object of study. In this paper we offer a systematic, and executable, framework for developing and comparing build systems, viewing them as related points in landscape rather than as isolated phenomena. By teasing apart existing build systems, we can recombine their components, allowing us to prototype new build systems with desired properties.}, -->
<!--         journal = {Proc. ACM Program. Lang.}, -->
<!--         month = jul, -->
<!--         articleno = {79}, -->
<!--         numpages = {29}, -->
<!--         keywords = {functional programming, build systems, algorithms} -->
<!--         } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="document-calculus"> -->
<!--       @article{Crichton_2024, -->
<!--         title={A Core Calculus for Documents: Or, Lambda: The Ultimate Document}, -->
<!--         volume={8}, -->
<!--         ISSN={2475-1421}, -->
<!--         url={http://dx.doi.org/10.1145/3632865}, -->
<!--         DOI={10.1145/3632865}, -->
<!--         number={POPL}, -->
<!--         journal={Proceedings of the ACM on Programming Languages}, -->
<!--         publisher={Association for Computing Machinery (ACM)}, -->
<!--         author={Crichton, Will and Krishnamurthi, Shriram}, -->
<!--         year={2024}, -->
<!--         month=jan, pages={667–694} } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="hazel"> -->
<!--       @misc{omar2018livefunctionalprogrammingtyped, -->
<!--         title={Live Functional Programming with Typed Holes},  -->
<!--         author={Cyrus Omar and Ian Voysey and Ravi Chugh and Matthew A. Hammer}, -->
<!--         year={2018}, -->
<!--         eprint={1805.00155}, -->
<!--         archivePrefix={arXiv}, -->
<!--         primaryClass={cs.PL}, -->
<!--         url={https://arxiv.org/abs/1805.00155},  -->
<!--   } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="simplest-sort"> -->
<!--       @misc{fung2021simplestandsurprisingsorting, -->
<!--         title={Is this the simplest (and most surprising) sorting algorithm ever?},  -->
<!--         author={Stanley P. Y. Fung}, -->
<!--         year={2021}, -->
<!--         eprint={2110.01111}, -->
<!--         archivePrefix={arXiv}, -->
<!--         primaryClass={cs.DS}, -->
<!--         url={https://arxiv.org/abs/2110.01111},  -->
<!--   } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-bibliography format="apa"> -->
<!--     </bh-bibliography> -->
<!--  -->
<!--     <bh-reference id="mcclellan2012"> -->
<!--       @article{mcclellan2012, -->
<!--       doi = {10.1088/1748-9326/7/3/034019}, -->
<!--       url = {https://dx.doi.org/10.1088/1748-9326/7/3/034019}, -->
<!--       year = {2012}, -->
<!--       month = {aug}, -->
<!--       publisher = {IOP Publishing}, -->
<!--       volume = {7}, -->
<!--       number = {3}, -->
<!--       pages = {034019}, -->
<!--       author = {Justin McClellan and David W Keith and Jay Apt}, -->
<!--       title = {Cost analysis of stratospheric albedo modification delivery systems}, -->
<!--       journal = {Environmental Research Letters}} -->
<!--       &#60;&#33;&#45;&#45; abstract = {We perform  engineering cost analyses of systems capable of delivering 1–5 million metric tonnes (Mt) of albedo modification material to altitudes of 18–30 km. The goal is to compare a range of delivery systems evaluated on a consistent cost basis. Cost estimates are developed with statistical cost estimating relationships based on historical costs of aerospace development programs and operations concepts using labor rates appropriate to the operations. We evaluate existing aircraft cost of acquisition and operations, perform in-depth new aircraft and airship design studies and cost analyses, and survey rockets, guns, and suspended gas and slurry pipes, comparing their costs to those of aircraft and airships. Annual costs for delivery systems based on new aircraft designs are estimated to be $1-3B to deliver 1 Mt to  20 30 km or $2-8B to deliver 5 Mt to the same altitude range. Costs for hybrid airships may be competitive, but their large surface area complicates operations in high altitude wind shear, and development costs are more uncertain than those for airplanes. Pipes suspended by floating platforms provide low recurring costs to pump a liquid or gas to altitudes as high as 20km, but the research, development, testing and evaluation costs of these systems are high and carry a large uncertainty; the pipe system’s high operating pressures and tensile strength requirements bring the feasibility of this system into question. The costs for rockets and guns are significantly higher than those for other systems. We conclude that (a) the basic technological capability to deliver material to the stratosphere at million tonne per year rates exists today, (b) based on prior literature, a few million tonnes per year would be sufficient to alter radiative forcing by an amount roughly equivalent to the growth of anticipated greenhouse gas forcing over the next half century, and that (c) several different methods could possibly deliver this quantity for less than $8B per year. We do not address here the science of aerosols in the stratosphere, nor issues of risk, effectiveness or governance that will add to the costs of solar geoengineering.}} &#45;&#45;&#62; -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="graf2022"> -->
<!--       @article{Graf_2022, -->
<!--         title={Binary Fuse Filters: Fast and Smaller Than Xor Filters}, -->
<!--         volume={27}, -->
<!--         ISSN={1084-6654}, -->
<!--         url={http://dx.doi.org/10.1145/3510449}, -->
<!--         DOI={10.1145/3510449}, -->
<!--         journal={ACM Journal of Experimental Algorithmics}, -->
<!--         publisher={Association for Computing Machinery (ACM)}, -->
<!--         author={Graf, Thomas Mueller and Lemire, Daniel}, -->
<!--         year={2022}, -->
<!--         month=mar, pages={1–15} } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="wydrowski2023loadbalanceintroducingprequal"> -->
<!--       @misc{wydrowski2023loadbalanceintroducingprequal, -->
<!--         title={Load is not what you should balance: Introducing Prequal},  -->
<!--         author={Bartek Wydrowski and Robert Kleinberg and Stephen M. Rumble and Aaron Archer}, -->
<!--         year={2023}, -->
<!--         eprint={2312.10172}, -->
<!--         archivePrefix={arXiv}, -->
<!--         primaryClass={cs.DC}, -->
<!--         url={https://arxiv.org/abs/2312.10172},  -->
<!--   } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="park2024iclrincontextlearningrepresentations"> -->
<!--       @misc{park2024iclrincontextlearningrepresentations, -->
<!--         title={ICLR: In-Context Learning of Representations},  -->
<!--         author={Core Francisco Park and Andrew Lee and Ekdeep Singh Lubana and Yongyi Yang and Maya Okawa and Kento Nishi and Martin Wattenberg and Hidenori Tanaka}, -->
<!--         year={2024}, -->
<!--         eprint={2501.00070}, -->
<!--         archivePrefix={arXiv}, -->
<!--         primaryClass={cs.CL}, -->
<!--         url={https://arxiv.org/abs/2501.00070},  -->
<!--   } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="libkind2024patternrunsmatterfree"> -->
<!--       @misc{libkind2024patternrunsmatterfree, -->
<!--         title={Pattern runs on matter: The free monad monad as a module over the cofree comonad comonad},  -->
<!--         author={Sophie Libkind and David I. Spivak}, -->
<!--         year={2024}, -->
<!--         eprint={2404.16321}, -->
<!--         archivePrefix={arXiv}, -->
<!--         primaryClass={math.CT}, -->
<!--         url={https://arxiv.org/abs/2404.16321},  -->
<!--   } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="fp2"> -->
<!--       @article{10.1145/3607840, -->
<!--         author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter}, -->
<!--         title = {FP²: Fully in-Place Functional Programming}, -->
<!--         year = {2023}, -->
<!--         issue_date = {August 2023}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         volume = {7}, -->
<!--         number = {ICFP}, -->
<!--         url = {https://doi.org/10.1145/3607840}, -->
<!--         doi = {10.1145/3607840}, -->
<!--         abstract = {As functional programmers we always face a dilemma: should we write purely   -->
<!--         functional code, or sacrifice purity for efficiency and resort to in-place   -->
<!--         updates? This paper identifies precisely when we can have the best of both   -->
<!--         worlds: a wide class of purely functional programs can be executed safely using   -->
<!--         in-place updates without requiring allocation, provided their arguments are not   -->
<!--         shared elsewhere.   -->
<!--          -->
<!--         We describe a linear _fully in-place_ (FIP) calculus where we prove that we can   -->
<!--         always execute such functions in a way that requires no (de)allocation and uses   -->
<!--         constant stack space. Of course, such a calculus is only relevant if we can   -->
<!--         express interesting algorithms; we provide numerous examples of in-place   -->
<!--         functions on datastructures such as splay trees or finger trees, together with   -->
<!--         in-place versions of merge sort and quick sort.   -->
<!--          -->
<!--         We also show how we can generically derive a map function over _any_ polynomial   -->
<!--         data type that is fully in-place. Finally, we have implemented the rules of the   -->
<!--         FIP calculus in the Koka language. Using the Perceus reference counting garbage   -->
<!--         collection, this implementation dynamically executes FIP functions in-place   -->
<!--         whenever possible.}, -->
<!--         journal = {Proc. ACM Program. Lang.}, -->
<!--         month = aug, -->
<!--         articleno = {198}, -->
<!--         numpages = {30}, -->
<!--         keywords = {FBIP, Tail Recursion Modulo Cons} -->
<!--         } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="verse"> -->
<!--       @article{10.1145/3607845, -->
<!--         author = {Augustsson, Lennart and Breitner, Joachim and Claessen, Koen and Jhala, Ranjit and Peyton Jones, Simon and Shivers, Olin and Steele Jr., Guy L. and Sweeney, Tim}, -->
<!--         title = {The Verse Calculus: A Core Calculus for Deterministic Functional Logic Programming}, -->
<!--         year = {2023}, -->
<!--         issue_date = {August 2023}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         volume = {7}, -->
<!--         number = {ICFP}, -->
<!--         url = {https://doi.org/10.1145/3607845}, -->
<!--         doi = {10.1145/3607845}, -->
<!--         abstract = {Functional logic languages have a rich literature, but it is tricky   -->
<!--          to give them a satisfying semantics. In this paper we describe the   -->
<!--          Verse calculus, VC, a new core calculus for deterministic functional   -->
<!--          logic programming. Our main contribution is to equip VC with a   -->
<!--          small-step rewrite semantics, so that we can reason   -->
<!--          about a VC program in the same way as one does with lambda   -->
<!--          calculus; that is, by applying successive rewrites to it.   -->
<!--          We also show that the rewrite system is confluent for well-behaved terms.}, -->
<!--         journal = {Proc. ACM Program. Lang.}, -->
<!--         month = aug, -->
<!--         articleno = {203}, -->
<!--         numpages = {31}, -->
<!--         keywords = {Verse calculus, Verse language, choice operator, confluence, declarative programming, evaluation strategy, even/odd problem, functional programming, lambda calculus, lenient evaluation, logic programming, logical variables, normal forms, rewrite rules, skew confluence, substitution, unification} -->
<!--         } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="dunning2021"> -->
<!--       @article{DUNNING2021100049, -->
<!--         title = {The t-digest: Efficient estimates of distributions}, -->
<!--         journal = {Software Impacts}, -->
<!--         volume = {7}, -->
<!--         pages = {100049}, -->
<!--         year = {2021}, -->
<!--         issn = {2665-9638}, -->
<!--         doi = {https://doi.org/10.1016/j.simpa.2020.100049}, -->
<!--         url = {https://www.sciencedirect.com/science/article/pii/S2665963820300403}, -->
<!--         author = {Ted Dunning}, -->
<!--         keywords = {Quantile estimation, t-digest, OLAP database, Open-source, Greenwald–Khanna algorithm}, -->
<!--         abstract = {The t-digest is an on-line algorithm for building small sketches of data that can be used to approximate rank-based statistics with high accuracy, particularly near the tails. This new kind of sketch is robust with respect to skewed distributions, repeated samples and ordered datasets. Separately computed sketches can be combined with little or no loss in accuracy. An open-source Java implementation with no external dependencies of this algorithm is available as a free-standing library. Independent implementations in Go, C++ and Python are available. The t-digest is in widespread internal use in major companies and is also available in popular software such as Postgres, ElasticSearch, Apache Kylin and Apache Druid. This research did not receive any specific grant from funding agencies in the public, commercial, or not-for-profit sectors.} -->
<!--         } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="Masson_2019"> -->
<!--       @article{Masson_2019, -->
<!--         title={DDSketch: a fast and fully-mergeable quantile sketch with relative-error guarantees}, -->
<!--         volume={12}, -->
<!--         ISSN={2150-8097}, -->
<!--         url={http://dx.doi.org/10.14778/3352063.3352135}, -->
<!--         DOI={10.14778/3352063.3352135}, -->
<!--         number={12}, -->
<!--         journal={Proceedings of the VLDB Endowment}, -->
<!--         publisher={Association for Computing Machinery (ACM)}, -->
<!--         author={Masson, Charles and Rim, Jee E. and Lee, Homin K.}, -->
<!--         year={2019}, -->
<!--         month=aug, pages={2195–2205} } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="hyperloglog"> -->
<!--       10.1.1.76.4286 -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="litt2022"> -->
<!--       @article{10.1145/3555644, -->
<!--         author = {Litt, Geoffrey and Lim, Sarah and Kleppmann, Martin and van Hardenberg, Peter}, -->
<!--         title = {Peritext: A CRDT for Collaborative Rich Text Editing}, -->
<!--         year = {2022}, -->
<!--         issue_date = {November 2022}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         volume = {6}, -->
<!--         number = {CSCW2}, -->
<!--         url = {https://doi.org/10.1145/3555644}, -->
<!--         doi = {10.1145/3555644}, -->
<!--         abstract = {Conflict-Free Replicated Data Types (CRDTs) support decentralized collaborative editing of shared data, enabling peer-to-peer sharing and flexible branching and merging workflows. While there is extensive work on CRDTs for plain text, much less is known about CRDTs for rich text with formatting. No algorithms have been published, and existing open-source implementations do not always preserve user intent.In this paper, we describe a model of intent preservation in rich text editing, developed through a series of concurrent editing scenarios. We then describe Peritext, a CRDT algorithm for rich text that satisfies the criteria of our model. The key idea is to store formatting spans alongside the plaintext character sequence, linked to a stable identifier for the first and last character of each span, and then to derive the final formatted text from these spans in a deterministic way that ensures concurrent operations commute.We have prototyped our algorithm in TypeScript, validated it using randomized property-based testing, and integrated it with an editor UI. We also prove that our algorithm ensures convergence, and demonstrate its causality preservation and intention preservation properties.}, -->
<!--         journal = {Proc. ACM Hum.-Comput. Interact.}, -->
<!--         month = nov, -->
<!--         articleno = {531}, -->
<!--         numpages = {36}, -->
<!--         keywords = {rich text, conflict-free replicated data types, collaborative editing, asynchronous collaboration} -->
<!--         } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="cnotlowlevel"> -->
<!--       @article{10.1145/3212477.3212479, -->
<!--         author = {Chisnall, David}, -->
<!--         title = {C Is Not a Low-level Language: Your computer is not a fast PDP-11.}, -->
<!--         year = {2018}, -->
<!--         issue_date = {March-April 2018}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         volume = {16}, -->
<!--         number = {2}, -->
<!--         issn = {1542-7730}, -->
<!--         url = {https://doi.org/10.1145/3212477.3212479}, -->
<!--         doi = {10.1145/3212477.3212479}, -->
<!--         abstract = {In the wake of the recent Meltdown and Spectre vulnerabilities, it’s worth spending some time looking at root causes. Both of these vulnerabilities involved processors speculatively executing instructions past some kind of access check and allowing the attacker to observe the results via a side channel. The features that led to these vulnerabilities, along with several others, were added to let C programmers continue to believe they were programming in a low-level language, when this hasn’t been the case for decades.}, -->
<!--         journal = {Queue}, -->
<!--         month = apr, -->
<!--         pages = {18–30}, -->
<!--         numpages = {13} -->
<!--         } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="cividis"> -->
<!--       10.1371/journal.pone.0199239 -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="li2022"> -->
<!--       @article{10.1093/jeg/lbab034, -->
<!--         author = {Li, Xiaodi}, -->
<!--         title = {Do new housing units in your backyard raise your rents?}, -->
<!--         journal = {Journal of Economic Geography}, -->
<!--         volume = {22}, -->
<!--         number = {6}, -->
<!--         pages = {1309-1352}, -->
<!--         year = {2021}, -->
<!--         month = {09}, -->
<!--         abstract = {There is a growing debate about whether new housing units increase rents for immediately surrounding apartments. Some argue new market-rate development produces a supply effect, which should alleviate the demand pressure on existing housing units and decrease their rents. Others contend that new development will attract high-income households and new amenities, generating an amenity effect and driving up rents. I contribute to this debate by estimating the impact of new high-rises on nearby residential rents, residential property sales prices and restaurant openings in New York City. To address the selection bias that developers are more likely to build new high-rises in fast-appreciating areas, I restrict the sample to residential properties near approved new high-rises and exploit the plausibly exogenous timing of completion conditional upon the timing of approval. I provide event study evidence that within 500 ft, for every 10\% increase in the housing stock, rents decrease by 1\%; and for every 10\% increase in the condo stock, condo sales prices decrease by 0.9\%. In addition, I show that new high-rises attract new restaurants, which is consistent with the hypothesis about amenity effects. However, I find that the supply effect dominates the amenity effect, causing net reductions in the rents and sales prices of nearby residential properties.}, -->
<!--         issn = {1468-2702}, -->
<!--         doi = {10.1093/jeg/lbab034}, -->
<!--         url = {https://doi.org/10.1093/jeg/lbab034}, -->
<!--         eprint = {https://academic.oup.com/joeg/article-pdf/22/6/1309/47258299/lbab034.pdf}, -->
<!--     } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="asquith2023"> -->
<!--       @article{10.1162/rest_a_01055, -->
<!--         author = {Asquith, Brian J. and Mast, Evan and Reed, Davin}, -->
<!--         title = {Local Effects of Large New Apartment Buildings in Low-Income Areas}, -->
<!--         journal = {The Review of Economics and Statistics}, -->
<!--         volume = {105}, -->
<!--         number = {2}, -->
<!--         pages = {359-375}, -->
<!--         year = {2023}, -->
<!--         month = {03}, -->
<!--         abstract = {We study the local effects of new market-rate housing in low-income areas using microdata on large apartment buildings, rents, and migration. New buildings decrease rents in nearby units by about 6\% relative to units slightly farther away or near sites developed later, and they increase in-migration from low-income areas. We show that new buildings absorb many high-income households and increase the local housing stock substantially. If buildings improve nearby amenities, the effect is not large enough to increase rents. Amenity improvements could be limited because most buildings go into already-changing neighborhoods or buildings could create disamenities such as congestion.}, -->
<!--         issn = {0034-6535}, -->
<!--         doi = {10.1162/rest_a_01055}, -->
<!--         url = {https://doi.org/10.1162/rest\_a\_01055}, -->
<!--         eprint = {https://direct.mit.edu/rest/article-pdf/105/2/359/2073255/rest\_a\_01055.pdf}, -->
<!--     } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="wydrowski2023"> -->
<!--       @misc{wydrowski2023loadbalanceintroducingprequal, -->
<!--         title={Load is not what you should balance: Introducing Prequal},  -->
<!--         author={Bartek Wydrowski and Robert Kleinberg and Stephen M. Rumble and Aaron Archer}, -->
<!--         year={2023}, -->
<!--         eprint={2312.10172}, -->
<!--         archivePrefix={arXiv}, -->
<!--         primaryClass={cs.DC}, -->
<!--         url={https://arxiv.org/abs/2312.10172},  -->
<!--       } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="neumann2015"> -->
<!--       @inproceedings{Neumann2015UnnestingAQ, -->
<!--         title={Unnesting Arbitrary Queries}, -->
<!--         author={Thomas Neumann and Alfons Kemper}, -->
<!--         booktitle={Datenbanksysteme f{\"u}r Business, Technologie und Web}, -->
<!--         year={2015}, -->
<!--         url={https://api.semanticscholar.org/CorpusID:15999707} -->
<!--       } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="neumann2024"> -->
<!--       @inproceedings{Neumann2024ACO, -->
<!--         title={A Critique of Modern SQL and a Proposal Towards a Simple and Expressive Query Language}, -->
<!--         author={Thomas Neumann and Viktor Leis}, -->
<!--         booktitle={Conference on Innovative Data Systems Research}, -->
<!--         year={2024}, -->
<!--         url={https://api.semanticscholar.org/CorpusID:268890301} -->
<!--       } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="boldyreva2009"> -->
<!--       @inproceedings{10.5555/3088723.3088749, -->
<!--       author = {Boldyreva, Alexandra and Chenette, Nathan and Lee, Younho and O'Neill, Adam}, -->
<!--       title = {Order-Preserving Symmetric Encryption}, -->
<!--       year = {2009}, -->
<!--       isbn = {9783642010002}, -->
<!--       publisher = {Springer-Verlag}, -->
<!--       address = {Berlin, Heidelberg}, -->
<!--       abstract = {We initiate the cryptographic study of order-preserving symmetric encryption OPE, a primitive suggested in the database community by Agrawal et al.\"{\i} \'{z}SIGMOD '04 for allowing efficient range queries on encrypted data. Interestingly, we first show that a straightforward relaxation of standard security notions for encryption such as indistinguishability against chosen-plaintext attack IND-CPA is unachievable by a practical OPE scheme. Instead, we propose a security notion in the spirit of pseudorandom functions PRFs and related primitives asking that an OPE scheme look "as-random-as-possible" subject to the order-preserving constraint. We then design an efficient OPE scheme and prove its security under our notion based on pseudorandomness of an underlying blockcipher. Our construction is based on a natural relation we uncover between a random order-preserving function and the hypergeometric probability distribution. In particular, it makes black-box use of an efficient sampling algorithm for the latter.}, -->
<!--       booktitle = {Proceedings of the 28th Annual International Conference on Advances in Cryptology - EUROCRYPT 2009 - Volume 5479}, -->
<!--       pages = {224–241}, -->
<!--       numpages = {18} -->
<!--       } -->
<!--     </bh-reference> -->
<!--  -->
<!--     <bh-reference id="hwang2015"> -->
<!--         @inproceedings{10.1145/2808425.2808431, -->
<!--         author = {Hwang, Yong Ho and Kim, Sungwook and Seo, Jae Woo}, -->
<!--         title = {Fast Order-Preserving Encryption from Uniform Distribution Sampling}, -->
<!--         year = {2015}, -->
<!--         isbn = {9781450338257}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         url = {https://doi.org/10.1145/2808425.2808431}, -->
<!--         doi = {10.1145/2808425.2808431}, -->
<!--         &#60;&#33;&#45;&#45; abstract = {Order-preserving encryption (OPE) is a symmetric encryption that ciphertexts preserve numerical ordering of the corresponding plaintexts. It allows various applications to search or sort the order of encrypted data (e.g., range queries in database) efficiently. In this paper, we study OPE for more practical use. We first discuss the elements of previous schemes considered as obstacles in practical applications and propose a new construction by eliminating them (especially probabilistic random variate generation functions such as hypergeometric and binomial distributions). We propose a new OPE whose encryption and decryption are much faster than those of the previous schemes by employing uniform distribution sampling. Furthermore, we provide a batch decryption algorithm to support concurrent decryption of numerical values within the specific range, which is firstly observed in the OPE research literature. It can be very efficiently applied for the encrypted range query processing of database systems. The security of our scheme is proven under the weak variants of notions proposed by Teranishi et al. in Asiacrypt 2014, which yield partial indistinguishability and one-wayness.}, &#45;&#45;&#62; -->
<!--         booktitle = {Proceedings of the 2015 ACM Workshop on Cloud Computing Security Workshop}, -->
<!--         pages = {41–52}, -->
<!--         numpages = {12}, -->
<!--         keywords = {uniform sampling, symmetric encryption, order-preserving}, -->
<!--         location = {Denver, Colorado, USA}, -->
<!--         series = {CCSW '15} -->
<!--         } -->
<!--     </bh-reference> -->
<!--     <bh-reference id="boehm2020"> -->
<!--       @inproceedings{10.1145/3385412.3386037, -->
<!--         author = {Boehm, Hans-J.}, -->
<!--         title = {Towards an API for the real numbers}, -->
<!--         year = {2020}, -->
<!--         isbn = {9781450376136}, -->
<!--         publisher = {Association for Computing Machinery}, -->
<!--         address = {New York, NY, USA}, -->
<!--         url = {https://doi.org/10.1145/3385412.3386037}, -->
<!--         doi = {10.1145/3385412.3386037}, -->
<!--         abstract = {The real numbers are pervasive, both in daily life, and in mathematics. Students spend much time studying their properties. Yet computers and programming languages generally provide only an approximation geared towards performance, at the expense of many of the nice properties we were taught in high school.  Although this is entirely appropriate for many applications, particularly those that are sensitive to arithmetic performance in the usual sense, we argue that there are others where it is a poor choice. If arithmetic computations and result are directly exposed to human users who are not floating point experts, floating point approximations tend to be viewed as bugs. For applications such as calculators, spreadsheets, and various verification tasks, the cost of precision sacrifices is high, and the performance benefit is often not critical. We argue that previous attempts to provide accurate and understandable results for such applications using the recursive reals were great steps in the right direction, but they do not suffice. Comparing recursive reals diverges if they are equal. In many cases, comparison of numbers, including equal ones, is both important, particularly in simple cases, and intractable in the general case.  We propose an API for a real number type that explicitly provides decidable equality in the easy common cases, in which it is often unnatural not to. We describe a surprisingly compact and simple implementation in detail. The approach relies heavily on classical number theory results. We demonstrate the utility of such a facility in two applications: testing floating point functions, and to implement arithmetic in Google's Android calculator application.}, -->
<!--         booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation}, -->
<!--         pages = {562–576}, -->
<!--         numpages = {15}, -->
<!--         keywords = {real numbers, decidability, comparison, API design}, -->
<!--         location = {London, UK}, -->
<!--         series = {PLDI 2020} -->
<!--         } -->
<!--     </bh-reference> -->
<!--     <bh-reference id="fong2025"> -->
<!--       @article{ -->
<!-- doi:10.1126/sciadv.adu1052, -->
<!-- author = {James Fong  and Hannah K. Doyle  and Congli Wang  and Alexandra E. Boehm  and Sofie R. Herbeck  and Vimal Prabhu Pandiyan  and Brian P. Schmidt  and Pavan Tiruveedhula  and John E. Vanston  and William S. Tuten  and Ramkumar Sabesan  and Austin Roorda  and Ren Ng }, -->
<!-- title = {Novel color via stimulation of individual photoreceptors at population scale}, -->
<!-- journal = {Science Advances}, -->
<!-- volume = {11}, -->
<!-- number = {16}, -->
<!-- pages = {eadu1052}, -->
<!-- year = {2025}, -->
<!-- doi = {10.1126/sciadv.adu1052}, -->
<!-- URL = {https://www.science.org/doi/abs/10.1126/sciadv.adu1052}, -->
<!-- eprint = {https://www.science.org/doi/pdf/10.1126/sciadv.adu1052}, -->
<!-- abstract = {We introduce a principle, Oz, for displaying color imagery: directly controlling the human eye’s photoreceptor activity via cell-by-cell light delivery. Theoretically, novel colors are possible through bypassing the constraints set by the cone spectral sensitivities and activating M cone cells exclusively. In practice, we confirm a partial expansion of colorspace toward that theoretical ideal. Attempting to activate M cones exclusively is shown to elicit a color beyond the natural human gamut, formally measured with color matching by human subjects. They describe the color as blue-green of unprecedented saturation. Further experiments show that subjects perceive Oz colors in image and video form. The prototype targets laser microdoses to thousands of spectrally classified cones under fixational eye motion. These results are proof-of-principle for programmable control over individual photoreceptors at population scale. Image display by cell-by-cell retina stimulation, enabling colors impossible to see under natural viewing.}} -->
<!--     </bh-reference> -->
<!--     <p style="padding-top: 5ch;"> -->
<!--       Powered by <a href="https://maxbo.me/celine/bibhtml">@celine/bibhtml</a> -->
<!--     </p> -->
  </main>
</body>
</html>
