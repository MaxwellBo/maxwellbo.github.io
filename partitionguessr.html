<!DOCTYPE html>
<html>
<head>
  <title>partitionguessr</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    /* We want to keep styling as minimal as possible. We want a "raw"
    HTML aesthetic */
    #map {
      width: 100%;
      height: 600px;
    }
  </style>
</head>
<body>
  <h1>partitionguessr</h1>

  <p>
    in partionguessr, you have to create an
    <a href="TODO">OpenStreetMap<a href="TODO">overpassturbo</a> query that when the results are joined together in its shortest <a href="TODO">Hamiltonian Path</a>, most effectively
    divides the poor from the rich. Of course, with a query long enough, one can draw an arbitrarily detailed path to more or less <a href="TODO">gerrymander</a>
    the polity. Thus, the the total query length has been limited to 256 characters.
  </p>

  <p>
    You are aiming for a 50%/50% split (0% difference). If you, instead, split by 55%/45%,
    your score will be 5% difference.

    Skill grades are:
    &lt; 5% GOLD
    &lt; 10% SILVER
    &lt; 15% BRONZE
  </p>

  <a href="https://honisoit.com/2017/09/food-fault-lines-mapping-class-division-through-food-chains/">https://honisoit.com/2017/09/food-fault-lines-mapping-class-division-through-food-chains/</a>
  <a href="https://x.com/SardineTruther/status/1924725005675593970?t=23LKn0gjnV0FRQWZ7a3f5A&s=19">https://x.com/SardineTruther/status/1924725005675593970?t=23LKn0gjnV0FRQWZ7a3f5A&s=19</a>

  <!-- We should really only need these dependencies -->
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7.0.0/turf.min.js"></script>

  <div>
    <form id="overpass-form">
      <!-- TODO: Limit the total character count to 256 -->
      <textarea id="overpass-query" rows="10" cols="60" placeholder="Enter your Overpass Turbo query here...">[out:json][timeout:25];

(
  node["name"~"Red Rooster", i]({{bbox}});
  way["name"~"Red Rooster", i]({{bbox}});
  relation["name"~"Red Rooster", i]({{bbox}});
);

out geom;</textarea>
      <br>
      <button type="submit">Run query</button>
    </form>
    <div id="query-status"></div>
  </div>

  <div id="map"></div>

  <pre id="geojson-out"></pre>

  <script type="module">
    const BBOX = [-34.02136404964111, 150.77362060546875, -33.67978264318627, 151.5220642089844];

    const osmtogeojson = await import('https://cdn.skypack.dev/osmtogeojson@3.0.0-beta.5?min')

    const map = L.map('map').setView([-33.8688, 151.2093], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
    }).addTo(map);

    document.getElementById('overpass-form').addEventListener('submit', async function(e) {
      e.preventDefault();
      let query = document.getElementById('overpass-query').value;
      const statusElement = document.getElementById('query-status');
      const geoJSONOutElement = document.getElementById('geojson-out');
      
      statusElement.textContent = 'Running query...';

      // replace the {{bbox}} placeholder with the actual bounding box coordinates
      query = query.replace(/{{bbox}}/g, BBOX.join(','));

      console.log(turf)
      
      try {
        // Clear existing GeoJSON layers and add the new data
        map.eachLayer(layer => {
          if (layer instanceof L.GeoJSON) {
            map.removeLayer(layer);
          }
        });

        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: 'data=' + encodeURIComponent(query),
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        });
        
        const data = await response.json();
        const geojson = osmtogeojson.default(data);

        // Create a new GeoJSON collection for the lines
        const lineCollection = {
          type: "FeatureCollection",
          features: []
        };

        // Extract all nodes for line creation
        const points = [];
        geojson.features.forEach(feature => {
          if (feature.geometry && (feature.geometry.type === "Point" || feature.geometry.type === "MultiPoint")) {
            if (feature.geometry.type === "Point") {
              points.push(feature.geometry.coordinates);
            } else if (feature.geometry.type === "MultiPoint") {
              points.push(...feature.geometry.coordinates);
            }
          }
        });

        // Create lines between consecutive points if there are at least 2 points
        if (points.length >= 2) {
          for (let i = 0; i < points.length - 1; i++) {
            const line = turf.lineString([points[i], points[i + 1]], {
              name: `Line ${i + 1}`,
              source: 'Generated line'
            });
            lineCollection.features.push(line);
          }
          
          // Add the line collection to the map
          L.geoJSON(lineCollection, {
            style: {
              color: '#ff7800',
              weight: 3,
              opacity: 0.65
            }
          }).addTo(map);
        }

        statusElement.textContent = 'Query completed successfully!';
        geoJSONOutElement.textContent = JSON.stringify(geojson, null, 2);
        
        L.geoJSON(geojson, {
          onEachFeature: function (feature, layer) {
            if (feature.properties) {
              layer.bindPopup(`<strong>${feature.properties.name || 'Unnamed'}</strong><br>ID: ${feature.properties.id || 'N/A'}`);
            }
          }
        }).addTo(map);
      } catch (error) {
        statusElement.textContent = 'Error running query: ' + error.message;
      }
    });
  </script>
</body>
</html>
